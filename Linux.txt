KeyNotes:
Monolithic Kernel(Linux -- consumes more running spaces) and Micro Kernel(Winodws -- consumes less running spaces)

The key difference between Linux kernel and Windows kernel is that Windows is a commercial software while Linux is open-source software.

In summary, the shell is the core component responsible for interpreting and executing commands, while the terminal is a graphical application that provides a user-friendly interface for accessing and interacting with the shell. Users use a terminal emulator to run a shell session and work with the command-line interface in a more user-friendly manner within their graphical desktop environment. Different terminal emulators may offer varying features and customization options, but they all serve as a bridge between the user and the shell.

## In summary, the working directory is the current directory, the parent directory is the directory above the current directory, the home directory is the default directory for a user, and the root directory is the top-level directory of the file system hierarchy.

Topic 1: Linux Introduction:

Linux Distributions:
Distribution		- Why To Use
UBuntu				- It works like Mac OS and easy to use.
Linux mint			- It works like windows and should be use by new comers.
Debian				- It provides stability but not recommended to a new user.
Fedora				- If you want to use red hat and latest software.
Red hat enterprise	- To be used commercially.
CentOS				- If you want to use red hat but without its trademark.
OpenSUSE			- It works same as Fedora but slightly older and more stable.
Arch Linux			- It is not for the beginners because every package has to be installed by yourself.
----------

1) To open a terminal, press CTRL+ALT+T keys.
2) vi filname.sh(to create a new shell file) > to edit the file, Press esc > i (insert) > write some program > To save, press esc > :wq!
3) To make a created file as executable, chmod +x filename.sh  (chmod is used to give root user permissions).
		Bootloader: It is a program that can load the Linux Kernel into the main memory of the computer by being run by the system after the initialization of the firmware is performed and when it's turned on.
		Init program: It is the initial process begun by the Linux Kernel.
		Software libraries: These include code that can be used by active processes.
		Basic Unix commands: Basic Unix commands, along with GNU coreutils, are the typical implementation. Several alternatives are available for embedded systems, like BSD-licensed Toybox and the copyleft BusyBox.
		Widget toolkits: They are the libraries utilized to create graphical user interfaces for software applications. Several widget toolkits are present, including Clutter and GTK integrated by the GNOME Project, Qt integrated by the Qt Project and conducted by the Enlightenment Foundation Libraries (EFL), and the Qt company primarily developed by the Enlightenment team.
		Package management system: The package management system includes RPM and dpkg. The packages can alternatively be compiled from source and binary tarballs.
		User interface program: The user interface programs are also available in Linux, such as windowing environments or command shells.
----------------------------
Envirronmental Variables:
a) PATH - This variable contains a list of directories in which our system looks for files. It separates directories by a (:) colon.
b) USER - This variable holds the username.
c) HOME - This variable holds the default path to the user's home directory.
d) EDITOR - This variable contains the path to the specified editor.
e) UID - This variable contains the path to the user's unique id.
f) TERM - This variable contains the path to the default terminal emulator.
g) SHELL - This variable contains the path to the default shell that is being used by the user.
h) ENV - This variable displays all the environment variable.

***********************************************************************************************************
echo new_variable  - The echo command is used to display the variable.
echo $new_variable  - To display the value of the variable, use the $ symbol before the variable name.
The env command is used to display all the available variables in the system.
Removing an Environment Variable: To remove an environment variable, execute the unset command followed by variable name. (example: unset variable name).
**********************************************************************************************************
Commands:

1) set command:
In Linux, the set command is used for a variety of purposes, including setting and modifying shell options, environmental variables, and positional parameters. Its behavior and usage can differ depending on the context in which it is used.
Example:
set -- help or set -h # For any help.
set -e  # Enable the "exit on error" option
set VARNAME=example  # Set an environmental variable named VARNAME
set -- arg1 arg2 arg3  # Set positional parameters to arg1, arg2, and arg3
set +x  # Disable or turn off debugging mode.
set -x  # Enable or turn on debugging mode.
Attributes or Options Supported:
-a: It is used to mark variables that are modified or created for export.
-b: It is used to notify of job termination immediately.
-e: It is used to exit immediately if a command exits with a non-zero status.
-f: It is used to disable the file name generation (globbing).
-h: It is used to save the location of commands where they looked up.
-k: It is used to place all assignment arguments in the environment variable of a command, except those that precede the command name.
-m: It is used to enable Job control.
-n: It is used to read commands.
-o: It is used for option-name.
-p: It is used to disable the processing of the '$ENV' file and import shell functions. It is turned on whenever the real and effective user ids do not match. Turning off this option may cause the working uid and gid to be set as the authorized uid and gid.
-t: It is used to exit from the command after executing one command.
-u: It is used to treat unset variables as an error when substituting.
-v: It is used to print shell input lines.
-x: It is used to print commands and their arguments in a sequential way (as they are executed).
-B: It is used to perform brace expansion by the Shell.
-C: It is used to disallow existing regular files to be overwritten by redirection of output.
-E: It is used if the ERR trap is inherited by the shell functions.
-H: It is used to enable style history substitution. By default, it is on when the shell is interactive.
-P: It is used if we do not want to follow symbolic links when executing commands.
-T: If this flag is set, the DEBUG trap is inherited by the shell functions.
####### Note: To turn off the above flags, use the '+' rather than '-' symbol.

2) export command: 
In Linux and Unix-like operating systems, the export command is used to set and export environmental variables. Environmental variables are values that can be accessed by programs and scripts running in the current shell session. When you export a variable, you make it available to child processes spawned from the current shell session. 
Examples:
export : The export command without any argument
export -p  :  Display all exported variable on current shell.
export -f function_name: Using export with functions.
Set vim as default editor: export EDITOR=/usr/bin/vim  
						   export | grep EDITOR
#################################################################################################################

Topic2: Linux Directories: 

Linux Directory Commands: 
Directory Command	- Description
pwd	   				- The pwd command stands for (print working directory). It displays the current working location or directory of the user. It displays the whole working path starting with /. It is a built-in command.
ls	 				- The ls command is used to show the list of a folder. It will list out all the files in the directed folder.
cd					- The cd command stands for (change directory). It is used to change to the directory you want to work from the present directory.
mkdir			    - With mkdir command you can create your own directory.
rmdir			    - The rmdir command is used to remove a directory from your system.

Linux Home Directory: 
The Linux home directory is a directory for a particular user of the system and consists of individual files. It is also referred to as the login directory. This is the first place that occurs after logging into a Linux system. It is automatically created as "/home" for each user in the directory'. It is a standard subdirectory of the root directory. The root directory contains all other directories, subdirectories, and files on the system. It is denoted by a forward slash (/).

The home directory can be said as a personal working space for all the users except root. There is a separate directory for every user. For example, two users 'jtp1' and 'jtp2' will have directories like "/home/jtp1" and "/home/jtp2". These users will have all the rights under their directory files.

The root (administrative) user is the only user who has its home directory in a different location by default. The path of the root user is '/root/', where it has control under all the directories and files.

How to find the Home Directory?
cd /home > ls

In Unix-like operating systems, including Linux, the commands cd ~ and cd $HOME are both used to navigate to the user's home directory. The home directory is the default directory where a user's personal files and settings are stored. Here's what each of these commands does:

cd ~: This command uses the tilde (~) symbol as a shorthand representation for the user's home directory. When you enter cd ~, the shell will change your current working directory to your home directory.

For example, if your username is "user123," cd ~ would take you to /home/user123.

cd $HOME: The $HOME variable is an environment variable that holds the path to your home directory. When you enter cd $HOME, you are using the value of the $HOME variable to navigate to your home directory. 

Some key differences between root and home directory are as following:
----------------------------------------------------------------------------------------------------------------------------------------------------------
                      Root Directory                 					|	Home Directory
---------------------------------------------------------------------------------------------------------------------------------------------------
The root directory is the topmost level of the system drive.			|   The home directory is a subdirectory of the root directory.
It is denoted by a slash '/'.	                                		|   It is denoted by '~' and has path "/users/username".
The admin has access to make any changes in the files and settings. 	|   No user other than the root user can change the settings of the entire system.
The admin can create a user.	                                    	|   Any user having a home directory cannot create a user.
In the Linux file system, everything comes under the root directory.	|   The home directory contains a particular user's data.
------------------------------------------------------------------------------------------------------------------------------------------------------------
Linux pwd command: pwd-present working directory.
Introduction to Woking Directory (Current)
The current working directory is a directory where the user is working currently. Each time we interact with our command prompt, we are working inside a directory. When we log into our Linux system, our current working directory is our home directory by default. We can use the cd command to change our working directory.

Syntax:
pwd 

Exit Status:
Non-zero: Failure
Zero: Success

PWD Options and their Explanation:
---------------------------------------------------------------------------------------------------
Options		| Explanation
-------------------------------------------------------------------------------------------------------
pwd	    	| This command is used to show the current working directory. For example, /home/foobar
pwd -L		| This command is used to show the logical path of the current working directory with the name of the symbolic link if any. For example, if existing in a dir /home/symlinked, it's a symlink to /home/realdir; it would display /home/symlinked.
pwd -R		| This command is used to show the physical path of the current working directory without the name of the symbolic link if any. For example, if existing in a dir /home/symlinked, it's a symlink to /home/realdir; it would display /home/realdir.
--help		| It shows the help message.
--version	| It provides the program version.
--------------------------------------------------------------------------------------------------------------
Linux cd command: cd-change directory.
Linux cd command is used to change the current working directory ( i.e., in which the current user is working). The "cd" stands for 'change directory.' It is one of the most frequently used commands in the Linux terminal.
cd can be used to modify into a subdirectory, return to the parent directory, move every way behind the root directory, or move to a given directory.

Syntax:
cd <dirname> 

Options of cd Command: 
Unix-like, Unix
cd ~ or cd : by itself will always bring the user to the home directory.
cd . : will allow the user to stay in the similar directory they are in currently.
cd ~username : will allow the user to stay in the home directory of the username.
cd dir : (not with /) will allow the user to stay in a subdirectory.
cd .. : will bring the user above one directory.
cd - : will change the user to the old directory.

ReactOS, Windows, OS/2, DOS"
No attributes show the current directory's full path.

-p: It prints the ultimate directory stack, like dirs.
-v: In this option, entries are displayed a single per line, anticipated by the stack positions.
-n: In this option, entries are covered before they grasp the screen's edge.
cd\ (Windows and DOS only) is used to return to the root directory. The cd\subdir command always consequently takes the user to the titled subdirectory in the root directory, despite where they are placed when the command is authorized.

cd ~ goes to home directory.
cd <path> goes to the specified path.
cd - change to the previous directory.
/run/cups$ cd /run/cups/certs goes to absoulte path i.e; in this example; /run/cups/certs$
cd. or cd.. change to parent directory.
cd/ change to the root directory.
cd ~username  change to another user's home directory.
cd Dir1/Dir2/Dir3....  Change up to multiple Sub Directories.

Linux Absolute and Relative Paths:
If currently you are in the root directory, then you can give command home or /home. 
The root directory itself has the absolute path of /.

>> Relative paths in Linux specify the location of a file or directory with respect to the current working directory. They don't start from the root directory but are based on your current location within the file system.
>> An absolute path in Linux specifies the complete and exact location of a file or directory in the file system, starting from the root directory ("/").

Linux ls command: 
The ls is the list command in Linux. It will show the full list or content of your directory. Just type ls and press the enter key. The whole content will be shown.
Names beginning with the "." symbol are hidden. The "." directory is known as the working directory, and the ".." symbol is known as its parent directory.

Linux ls command options
-------------------------------------------------------------------------------------------------------------------------------------------
		ls option			| 										Description
----------------------------------------------------------------------------------------------------------------------------------------------
ls -a						| In Linux, hidden files start with . (dot) symbol and they are not visible in the regular directory. The (ls -a) command will enlist the whole list of the current directory including the hidden files.
ls -l						| It will show the list in a long list format.
ls -lh	   					| This command will show you the file sizes in human readable format. Size of the file is very difficult to read when displayed in terms of byte. The (ls -lh)command will give you the data in terms of Mb, Gb, Tb, etc.
ls -lhS						| If you want to display your files in descending order (highest at the top) according to their size, then you can use (ls -lhS) command.
ls -l - -block-size=[SIZE]	| It is used to display the files in a specific size format. Here, in [SIZE] you can assign size according to your requirement.
ls -d */					| It is used to display only subdirectories.
ls -g or ls -lG				| With this you can exclude column of group information and owner.
ls -n						| It is used to print group ID and owner ID instead of their names.
ls --color=[VALUE]			| This command is used to print list as colored or discolored.
ls -li						| This command prints the index number if file is in the first column.
ls -p						| It is used to identify the directory easily by marking the directories with a slash (/) line sign.
ls -r						| It is used to print the list in reverse order.
ls -R						| It will display the content of the sub-directories also.
ls -lX						| It will group the files with same extensions together in the list.
ls -lt						| It will sort the list by displaying recently modified filed at top.
ls ~						| It gives the contents of home directory.
ls ../						| It give the contents of parent directory.
ls --version				| It checks the version of ls command.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

>> When we use ls -l command; Columns from result indicate specific things:
Column 1 indicates information regarding file permission.
Column 2 indicates the number of links to the file.
Column 3 & 4 indicates the owner and group information.
Column 5 indicayes size of the file in bytes.
Column 6 shows th date and time on which the file was recently modified.
Column 7 shows the file or directory name.

>>ls -l - -block-size=[SIZE]	
You can replace [SIZE] with the following measures:

K = Kilobyte
M = Megabyte
G = Gigabyte
T = Terabyte
P = Petabyte
E = Exabyte
Z = Zettabyte
Y = Yottabyte
>>Open the last modified file with ls -t
It can sort the file by edited time, displaying the last modified file first. To open the last modified file in the current working directory, we can use the ls command and head commands: ls -t | head -1  
>> Show directory information
When we use "ls -l", we will get the information of the directories content. But if we wish to see the information of the directory, we can use the -d option.
For instance, if we use the ls -l /etc command, it will show every file in the etc directory. But, if we wish to show the details of the /etc directory, we can use the -ld option. The command is as follows:

$ ls -l /etc  
$ ls -ld /etc  
>> Older files related to the last edited time (reverse order)
We can use the ls -ltr command for sorting the file names shown in the sequence of the last edited time in the reverse sequence. It will show the last modified file in the end line. It becomes more accessible when the listing process goes lengthy. The command is mentioned below: ls -ltr  

mkdir Command in Linux/Unix with Examples: 
The mkdir stands for 'make directory'. With the help of mkdir command, you can create a new directory wherever you want in your system. Just type "mkdir <dir name> , in place of <dir name> type the name of new directory, you want to create and then press enter.
We can make multiple directories by setting the directories using permissions with the mkdir command. We can't make directories without permission, and we might face the "permission denied" error. The directories that should be made are required to be named, so mkdir creates that particular directory when the directory doesn't exist upon that name. But if that name exists, the mkdir command will not make the directory.

Syntax: mkdir <dirname>  
>>Note: If you will not provide a path then by default your file will be created in your current directory only. If you want to create your directory some where else, then provide the path of your destination directory and your file will be created there.

To make multiple directories:
Syntax: mkdir <dirname1> <dirname2> <dirname3> ...  
Example: mkdir file1 file2 file3 

Mkdir Options: 
----------------------------------------------------------------------------------------------------------------------------------
		Options		| 					Description
----------------------------------------------------------------------------------------------------------------------------------
mkdir -p, -parents	| Add directory including its sub directory.
mkdir -v, -verbose	| Print a message for each created directory.
mkdir -m -mode=MODE	| Set access privilege. Example, mkdir -m 644 example_directory.
-Z					| It sets the SELinux security context of all created directories to their default type.
--context[=CTX]		| It works like the -Z option. If the CTX is mentioned, it sets the SMACK or SELinux security context to CTX.
--version			| It shows the version number and some details of the license and then exits.
--help				| It shows the help-related details and then exits.
----------------------------------------------------------------------------------------------------------------------------------

rmdir Command in Linux/Unix with Examples: 
This command is used to delete a directory. But will not be able to delete a directory including a sub-directory. It means, a directory has to be empty to be deleted.

Syntax: rmdir <dirname>
rmdir -p : This command will delete a directory including its sub-directories all at once. In below picture, all sub-directories have been deleted with 'rmdir -p' command.

Rename Folder in Linux: https://www.javatpoint.com/rename-folder-in-linux

#############################################################################################################################################################################################################33

Topic3: Linux commands List
------------------------------------------------------------------------------------------------------------------------------------------------
Commands	             |                         Description
-------------------------------------------------------------------------------------------------------------------------------------------------
alias					 |		Converts complex commands into simpler ones.
bzip2 / bunzip2			 |		Compresses a file / Decompress a bzip2 file.
bzcat / bzmore			 |		Displays files compressed with bzip2.
cal						 |		Displays calendar.
cat						 |		It is a multi-function command.
cd						 |		Changes the current working directory.
chage					 |		Sets an expiration date for a user account.
chgrp					 |		Changes group.
chmod					 |		Changes permission for a file or directory.
chown					 |		Changes the owner of a file or directory.
chsh					 |		Changes the shell.
clear					 |		Clears the terminal.
comm					 |		Compares two streams or files.
cp						 |		Copies file content from one file to another file.
cut						 |		Used to display the desired column from a file.
date					 |		Displays the current date.
df						 |		Checks the disk space in the system.
echo					 |		Prints the typed word on the terminal.
exit					 |		Exits from the current user group to the last group.
export					 |		Exports shell variables to other shells.
file					 |		Displays the type of file.
find					 |		Finds files for a particular search.
gpasswd					 |		Transfers group membership to another user.
grep					 |		Filters lines of text containing a certain string.
groupadd				 |		Creates a group.
groupdel				 |		Permanently removes a group.
groupmod				 |		Changes group name.
groups					 |		Displays the group name to which the current user belongs to.
gzip / gunzip			 |		Compresses a file / Decompress a gzip file.
head					 |		Displays the first ten lines of a file.
history					 |		Displays older commands from the shell command history.
HISTSIZE				 |		Determines the number of commands to be stored in the current environment.
HISTFILE				 |		Displays the file that contains the history.
HISTFILESIZE			 |		Sets the number of commands kept in the history file.
id						 |		Tells about the user's id in the system.
less					 |		Displays file content according to the width of the terminal.
locate	                 |		Searches a file in the database.
ls						 |		Lists all the files of a directory.
man						 |		Displays the manual page for the specified command.
mkdir					 |		Creates directory.
more					 |		Displays one output screen at a time.
mv						 |		Renames directories or files.
od						 |		Displays a file content in octal format.
passwd					 |		Set a password for a user group.
pwd						 |		Display the current working directory location.
PS1	                     |      Change the prompt name in the terminal.
rename					 |		Renames more than one file at once.
rm						 |		Removes a file.
rmdir					 |		Removes a directory.
set -o noclobber		 |		Prevents file from getting overwritten.
set +o noclobber		 |		Allows overwriting in the existing file.
set -u					 |		Displays undefined variables as an error.
set +u					 |		Displays nothing for an undefined variable.
set -x					 |		Displays shell expansion.
set +x					 |		Disables shell expansion.
sed	 					 |		Performs editing in streams.
sleep					 |		Waits for the specified number of seconds.
sort					 |		sorts the content in alphabetical order.
su	 					 |		It allows a user to run a shell as another user.
sudo					 |		It allows a user to start a program with the credentials of another user.
tac						 |		Displays file content in the opposite order.
tail					 | 		Displays the last ten lines of a file.
tar						 |		Compresses a directory.
tee						 |		Puts stdin on stdout and then into a file.
time					 |		Displays time taken to execute a command.
touch					 |		It creates an empty file.
tr						 |		Translates characters.
type					 |		Displays information about command type.
uniq					 |		Sorts and display multi times repeating lines only once.
unset					 |		Removes a variable from a shell.
useradd					 |		Adds users.
userdel					 |		Deletes users.
usermod					 |		Modifies the properties of a user.
vi						 |		Opens vi editor to write a program.
w						 | 		Displays who is logged on and what are they doing.
wc						 |		Counts words, lines, and characters.
who						 |		Tells who is logged on the system.
whoami					 |		Tells the name of the user.
who am i				 |		Displays the line pointing to your current session.
zcat / zmore			 | 		Views the files compressed with gzip.
------------------------------------------------------------------------------------------------------------------------------------------------
50 Linux Commands List with Examples : https://www.javatpoint.com/linux-commands
#################################################################################################################################################################################################################33

Topic4: Linux Introduction To Users
a) whoami - It tells you about the system's username.
b) who - The who command gives the information about the users logged on to the system.
c) who am i - This command displays the information about the current user only.
d) w - This command tells about the users who are logged in and what are they doing.
e) id - This command tells about your user id, primary group id, and a list of groups that belongs to you.

Linux Create User | Linux Add user | Linux user add command: 
The Linux server allows us to create more than one user after installation. Linux is a Multi-user system, which means more than one user can work in the same system at the same time. We are allowed to do so through the Setup agent.

We must have to create an account in order to work with Linux as we cannot keep working with the root account. We have one administrative account; a system administrator account is responsible for managing the user accounts and groups of the system.

Adding or removing a user is one of the most basic tasks of a new Linux server.

>>Create User in Linux (Ubuntu):
There are two most common ways to add a user to a Linux server.
		Graphically through user manager
		By the useradd command (Terminal)
1. By Graphically through user manager
Linux GUI allows us to create a user from its functions. It is a straight forward process. To create a user to your Linux server, follow the below steps:

Step1: Goto system search and search for the setting and navigate to Detail-> About.
Step2: Click on the Users after that Unlock option given on the header. It will ask for the system security password to enter the password and click ok to continue. Consider the below image:
Step3: Click on the Add User option to add a new user.
Step4: Enter the user details like username and password and account type. We can create two types of accounts, which are Standard and Administrator. The standard account does not contain the sudo privilege. However, we can provide it later.
Step5: Now, we have successfully created a new user called JTP2. Consider the below image.
------------------
2. By the Linux useradd command
In Linux, useradd command is a command-line utility which is used to add or remove a user on a Linux server and Unix based operating system.

In a different type of Linux distribution, the useradd command may be slightly different.

The useradd command performs the below tasks:

It edits the files for newly created user like /etc/passwd, /etc/shadow, /etc/group and /etc/gshadow.
It creates and opens a new home directory.
It allows us to set ownerships and permissions to the home directory.
Syntax: useradd [options] username 
In order to use the useradd command, we have to log-in with root or sudo access.

Before using Linux useradd command, let's understand some common terms that are used in the Linux command line.
Username: A username is a name that is used to login to the Linux system. It is displayed when we turn on our machine. The username length should be between 1 to 32 characters.
Password: A password is a secret code that is used to protect your system from unauthorized access. It is stored in etc/shadow file in an encrypted format.

User ID (UID): Linux provide a unique Id to every user; it is called user identification number or User ID or UID. By default, the UID for the root user is reserved as zero, and the remaining UID from 1 to 99 is reserved for other predefined accounts. Further, UID's from 100-999 are reserved for groups and system accounts.

Group ID (GID): The GID or Group ID is a group identification number provided by the Linux system. It is stored in /etc/group file.
User Info: It allows us to define some additional information about the user, such as user full name. It is optional.

Home Directory: It is an absolute location for a user.
Shell: It is an absolute location of a user's shell i.e. /bin/bash.

Create a user with a home directory
Sometimes the newly created user may or may not assign a home directory. To create a user and to forcefully assign a home directory to it, execute the below command:

sudo useradd -m Demo  

Create a user with a different home directory
Linux allows us to create a home directory on a different place instead of the default folder. Use the -d option with useradd command to create a different home directory. Execute the below command:

sudo useradd -m -d /Demo1 Demo1  
Create a user with an expiry date
To create a user with an expiry date that means after a particular date, it will be auto-deleted.

sudo useradd -d /home/test -e 2020-03-16 Demo2  
---------
Linux su Commands: https://www.javatpoint.com/linux-su-commands

Linux User Management:
User management includes everything from creating a user to deleting a user on your system. User management can be done in three ways on a Linux system.
-Graphical tools are easy and suitable for new users, as it makes sure you'll not run into any trouble.
-Command line tools includes commands like useradd, userdel, passwd, etc. These are mostly used by the server administrators.
-Third and very rare tool is to edit the local configuration files directly using vi.
			/etc/passwd  
The local user database in Linux is /etc/passwd directory.
a) root - The root user is the superuser and have all the powers for creating a user, deleting a user and can even login with the other user's account. The root user always has userid 0.
b) useradd - With useradd commands you can add a user.
	Syntax: useradd -m -d /home/<userName> -c "<userName>" <userName>  
c) root - The root user is the superuser and have all the powers for creating a user, deleting a user and can even login with the other user's account. The root user always has userid 0.
d) useradd - With useradd commands you can add a user.
	Syntax: useradd -m -d /home/<userName> -c "<userName>" <userName> 
	Example: useradd -m -d /home/xyz -c "xyz" xyz 
			Look at the above snapshot, we have created a user xyz along with creating a home directory (-m), setting the name of home directory (-d), and a description (-c).
			The 'xyz' received userid as 1004 and primary group id as 1004.
e) /etc/default/useradd - File /etc/default/useradd contains some user default options. The command useradd -D can be used to display this file.
	Syntax: useradd -D  
f) userdel - To delete a user account userdel command is used.
	Syntax: userdel -r <userName> 
g) usermod - The command usermod is used to modify the properties of an existing user.
	Syntax: usermod -c <'newName'> <oldName>
	Example: usermod -c 'jhonny' john  ( Look at the above snapshot, user name john is replaced by the new user name jhonny).
h) /etc/skel/ - The /etc/skel/ contains some hidden files which have profile settings and default values for applications. Hence, it serves as a default home directory and user profile. While using useradd -m option, the /etc/skel/ is copied to the newly 	created directory.
i) Deleting Home Directories - By using userdel -r option, you can delete home directory along with user account.
	Syntax: userdel -r <userName>  
j) Login Shell - The /etc/passwd file also tells about the login shell for the user.
	Example : usermod -s /bin/bash jtp  
k) chsh - Users can change their login shell with chsh command. Both the command chsh and chsh -s will work to change the shell.
	Syntax: chsh or chsh -s <newShell> 
	Example: chsh -s /bin/sh 
------
Linux User Password : 
- This chapter tells you about the local users password. You will learn here to change the password, set the password using different methods.
- First method is by using passwd command.
- Second method is with openssel passwd command.
https://www.javatpoint.com/linux-user-password
----
Linux Groups :
Users can be listed in different groups. Group allow us to set permission on the group level instead of setting the permission on individual level.

Every Linux distribution have a graphical tool to manage groups. Groups can be managed by graphical tools, command line tools and by vi or vigr depending upon the user's experience. Only experienced users should use vi or vigr to manage groups, since it will do proper locking or changes in the file.

a) groupadd : The groupadd command creates or add a group in our system.
	Syntax: groupadd <groupName> 
b) Group File : The /etc/group file defines the group membership. A user can be a member of more than one group.
	Syntax: /etc/group  
NOTE: If you type the above in terminal, would be getting some info where first column indicates group name, second is the group's encrypted password which may remain empty also, third is group identification (GID) and fourth is the list of members. Fourth list is empty as these groups do not have members.	
c) Groups : The group command tells about the group where current user belongs to.
	Syntax: groups  
d) usermod : The group members can be edited with usermod or useradd command. If a group is not listed then by default, usermod command will remove the user from every group of which he is a member. Here, -a (append) option is used to prevent this from happening.
	Syntax: usermod -a -G <group> <userName> 
e) groupmod : With the help of groupmod command you can change the name of an already existing group.
	Syntax: groupmod -n <oldGroup> <newGroup> 
f) gruopdel : The command groupdel will delete a group permanently from the system.
	Syntax: groupdel <group>
g) gpasswd : Control of group membership can be passed on to another user with gpasswd command.
	Syntax: gpsswd -A <user> <group> 
> Group administrators need not to be a member of the group. They can add or remove a member without being a member of that group.
> File /etc/gshadow keeps the information about the group administrators as shown in below snapshot.
> To remove all the administrators from a group, set an empty administrator list.
	Syntax: gpasswd -A "" <group>
------------
Linux Add User to Group:
- Linux allows us to add users to a specific user group. A user account can be added to more than one group. For example, the users that have sudo rights can access the sudo commands to gain related permission. Moreover, we can configure the file permission and other rights to a group.
- Adding a user to a group is a straight forward process, all we need to execute the appropriate command. We will walk through all the scenarios related to user and group, such as how to add, delete, remove users to a group. Moreover, we will also learn how to list groups. First, understand the Linux groups:

Linux Groups: 
- Linux groups are the community of the users that have the right to administrate and organize the users and file permission in a Linux system. The main motive of creating a group is to define the set of permissions such as read and write permission or allowing the shared resources of groups.

Types of Linux Groups:
In Linux-based system, there are two types of groups, which are:
			Primary group
			Secondary or supplementary group
i) Primary group: When we create a file through a specific user account, by default, the filegroup is set to the user's primary group. It will provide the same name as the file user group as the user account name. The primary group stores the user information in /etc/passwd file.

ii) Secondary or supplementary group: The main motive to create a secondary group is to allow the specific permission to limited users. For example, if we want to add any user to the sudo group, the added user will inherit the sudo rights, and be able to run the sudo commands. If we add a user to the docker group, then it will inherit the properties of the docker group and be able to run the docker commands.
> A user can be added to precisely one primary group. It is not necessary to add a user to a secondary group, so a user can be added to zero or more secondary groups.
Note: Only the root user has the right to add a user to a group.

a) Add a Group:  To create a new user group on a Linux system, execute the groupadd command, followed by the group name. You will need the sudo access to gain the elevated permissions. Execute the command as follows:
		sudo groupadd jtpGroup  
> The above command will ask for the system administrative password, type the password. 

Q1) How to add a user to a Group ?
Adding users to a group is a straight forward process. We can add users to a group by using usermod command. To add a user to a group, execute this command, followed by the group name and user name. The group name is the name of a group in which you want to add a particular user.
-let's create two users, user1 and user2, execute the command as follows:
	sudo useradd user1  
	sudo useradd user2  
The above command will add the two users called user1 and user2.
- To add the user to a group, execute the following command:
	sudo usermod -a -G jtpGroup user1   
The -a option used to append the group; it is recommended to use this option when adding a new user to a group. If you do not use the -a option, the user will be removed from any group not specified after -G option.

If the usermod command executes successfully, it will not display any output, but in case of failure, it will post warning messages such as user or group does not exist.

b) Add a user to multiple groups: 
Linux system allows us to add a user to various groups. However, a user only can be added to one primary group, but it can be added to any number of the secondary group.
- To assign a user to a secondary group, use the usermod command, followed by group names ( separate them by a comma) and user name.
- let's create secondary groups named JtpGroup2 and JtpGroup3:
	sudo usermod -a -G jtpGroup, JtpGroup2, JtpGroup3 user1  
The above command will add the user1 to JtpGroup2 and JtpGroup3 without removing it from JtpGroup.

c) List the Groups in Linux:
Many groups exist in Linux; these groups can be user-defined as well as pre-defined. We can list all the available groups by using getent command.
- To list all the available groups in the Linux system, execute the command as follows:
	getent group  
The above command will display a large list of pre-defined and user-defined groups. 

d) Remove a User from Group: 
The Linux system allows us to remove a user from a group. To remove a user from a group, execute the gpasswd command with -d option followed by group name and user name. Consider the below command:
	sudo gpasswd -d user1 jtpGroup  

e) Change a User's Primary Group: 
A user can be added to more than one group. In such scenarios, there will be only one primary group, and the others will be secondary groups. The access permission of files will be assigned to the primary group. Sometimes we may need to change the primary group; it can be changed by using the usermod command.
- To change the user's primary group, execute the usermod command as follows:
		sudo usermod -g JtpGroup2 user1 
-----------
Linux id Command: 
> Linux id command is used to print the genuine and effective user ID and group ID. A user ID (UID) is a particular user identity, whereas group IDs (GIDs) can contain more than one user's identity. This command is a useful tool for user management.
> Tracing the names of users and groups, and their corresponding UIDs and GIDs is a complex task for the new user. This is important for user management. In such cases, the id command will help us.
	Syntax: id [option]... [user name]  
Options:
The supported options by the id command are as following:
-a: It is used to ignore the compatibility with other versions.
-Z, --context: It is used to print only the security context of the process.
-g, --group: It is used to print only the effective GID.
-G, --groups: It is used to print all group Ids.
-n, --name: It is used to print a name instead of a number.
-r, --real: It is used to print the real ID instead of the effective ID, with -ugG
-u, --user: It is used to print only the effective UID.
-z, --zero: It is used to delimit entries with NULL characters, except the whitespace;
--help: It used to display the help documentation and exit.	
Q) How to use it?
> The id command is a built-in utility; therefore, we do not need to install any additional tools to use it. The 'id' command can be used without arguments. Execute the command as follows: "id" 
a) Find a specific user's UID: To find a user's specific user ID, execute the command with the '-u' option. For example. Find the user Id for the user 'javatpoint', execute the command as follows: "id -u javatpoint"
b) Find a specific user's GID: To find a specific user's GID, execute the command with the '-g' option. For example, to find the GID for the user 'javatpoint', execute the command as follows: "id -g javatpoint"
c) Display the real GID and UID instead of effective: We can display the real UID and GID instead of effective ids by executing the command with the '-r' option.
> To display the real UID and GID for the user 'javatpoint', execute the following commands:
	id -r -u javatpoint  
	id -r -g javatpoint  
d) Display all the different Group IDs: To display all the different GIDs, execute the command with the '-G' option as follows:	"id -G"
e) Display effective GROUP ID: To display only the effective GID, execute the command with the '-g' option as follows: "id -g"    
f) Getting Help: If you get stuck during the use of the id command, you can take help from your terminal. You can read the manual page and help documentation. To take help, execute the below command: "id --help" 

To read the manual, execute the command as follows: "man id"
##############################################################################################################################################################################################################################

Topic5: Linux Files:

- In Linux system, everything is a file and if it is not a file, it is a process. A file doesn't include only text files, images and compiled programs but also include partitions, hardware device drivers and directories. Linux consider everything as as file.
- Files are always case sensitive. example-we have two files named as 'Demo.txt' and 'demo.txt'. Although, they both share the same name but still they are two different files.

Types of Files:
a) Regular files (-): It contain programs, executable files and text files.
b) Directory files (d): It is shown in blue color. It contain list of files.
c) Special files
		i)Block file (b)
		ii)Character device file (c)
		iii)Named pipe file (p)
		iv)Symbolic link file (l)
		v)Socket file (s)
Linux File Commands :
-------------------------------------------------
Command	|    Description
-------------------------------------------------
file	| Determines file type.
touch	| Used to create a file.
rm	    | To remove a file.
cp	    | To copy a file.
mv	    | To rename or to move a file.
rename	| To rename file.
-------------------------------------------------
 IMP: Linux File System (for ref) https://www.javatpoint.com/linux-file-system
- A Linux file system is a structured collection of files on a disk drive or a partition. A partition is a segment of memory and contains some specific data. In our machine, there can be various partitions of the memory. Generally, every partition contains a file system.

- The general-purpose computer system needs to store data systematically so that we can easily access the files in less time. It stores the data on hard disks (HDD) or some equivalent storage type. There may be below reasons for maintaining the file system:
> Primarily the computer saves data to the RAM storage; it may lose the data if it gets turned off. However, there is non-volatile RAM (Flash RAM and SSD) that is available to maintain the data after the power interruption.
> Data storage is preferred on hard drives as compared to standard RAM as RAM costs more than disk space. The hard disks costs are dropping gradually comparatively the RAM.

The Linux file system contains the following sections:
	The root directory (/)
	A specific data storage format (EXT3, EXT4, BTRFS, XFS and so on)
	A partition or logical volume having a particular file system.
Q) What is the Linux File System?
- Linux file system is generally a built-in layer of a Linux operating system used to handle the data management of the storage. It helps to arrange the file on the disk storage. It manages the file name, file size, creation date, and much more information about a file.
- If we have an unsupported file format in our file system, we can download software to deal with it.

Linux File System Structure:
> Linux file system has a hierarchal file structure as it contains a root directory and its subdirectories. All other directories can be accessed from the root directory.
> A file system is designed in a way so that it can manage and provide space for non-volatile storage data. All file systems required a namespace that is a naming and organizational methodology. The namespace defines the naming process, length of the file name, or a subset of characters that can be used for the file name. It also defines the logical structure of files on a memory segment, such as the use of directories for organizing the specific files. Once a namespace is described, a Metadata description must be defined for that particular file.
> The data structure needs to support a hierarchical directory structure; this structure is used to describe the available and used disk space for a particular block. It also has the other details about the files such as file size, date & time of creation, update, and last modified.
> Also, it stores advanced information about the section of the disk, such as partitions and volumes.
> The advanced data and the structures that it represents contain the information about the file system stored on the drive; it is distinct and independent of the file system metadata.
imp Image: https://static.javatpoint.com/linux/images/linux-file-system.png

The file system requires an API (Application programming interface) to access the function calls to interact with file system components like files and directories. API facilitates tasks such as creating, deleting, and copying the files. It facilitates an algorithm that defines the arrangement of files on a file system.

The first two parts of the given file system together called a Linux virtual file system. It provides a single set of commands for the kernel and developers to access the file system. This virtual file system requires the specific system driver to give an interface to the file system.

Directory Structure:

The directories help us to store the files and locate them when we need them. Also, directories are called folders as they can be assumed of as folders where files reside in the form of a physical desktop analogy. Directories can be organized in a tree-like hierarchy in Linux and several other operating systems.

The directory structure of Linux is well-documented and defined in the Linux FHS (Filesystem Hierarchy Standard). Referencing those directories if accessing them is achieved via the sequentially deeper names of the directory linked by '/' forward slash like /var/spool/mail and /var/log. These are known as paths.

The below table gives a very short standard, defined, and well-known top-level Linux directory list and their purposes:

/ (root filesystem): It is the top-level filesystem directory. It must include every file needed to boot the Linux system before another filesystem is mounted. Every other filesystem is mounted on a well-defined and standard mount point because of the root filesystem directories after the system is started.
/boot: It includes the static kernel and bootloader configuration and executable files needed to start a Linux computer.
/bin: This directory includes user executable files.
/dev: It includes the device file for all hardware devices connected to the system. These aren't device drivers; instead, they are files that indicate all devices on the system and provide access to these devices.
/etc: It includes the local system configuration files for the host system.
/lib: It includes shared library files that are needed to start the system.
/home: The home directory storage is available for user files. All users have a subdirectory inside /home.
/mnt: It is a temporary mount point for basic filesystems that can be used at the time when the administrator is working or repairing a filesystem.
/media: A place for mounting external removable media devices like USB thumb drives that might be linked to the host.
/opt: It contains optional files like vendor supplied application programs that must be placed here.
/root: It's the home directory for a root user. Keep in mind that it's not the '/' (root) file system.
/tmp: It is a temporary directory used by the OS and several programs for storing temporary files. Also, users may temporarily store files here. Remember that files may be removed without prior notice at any time in this directory.
/sbin: These are system binary files. They are executables utilized for system administration.
/usr: They are read-only and shareable files, including executable libraries and binaries, man files, and several documentation types.
/var: Here, variable data files are saved. It can contain things such as MySQL, log files, other database files, email inboxes, web server data files, and much more.

Linux File System Features :
- In Linux, the file system creates a tree structure. All the files are arranged as a tree and its branches. The topmost directory called the root (/) directory. All other directories in Linux can be accessed from the root directory.

Some key features of Linux file system are as following:
i) Specifying paths: Linux does not use the backslash (\) to separate the components; it uses forward slash (/) as an alternative. For example, as in Windows, the data may be stored in C:\ My Documents\ Work, whereas, in Linux, it would be stored in /home/ My Document/ Work.
ii) Partition, Directories, and Drives: Linux does not use drive letters to organize the drive as Windows does. In Linux, we cannot tell whether we are addressing a partition, a network device, or an "ordinary" directory and a Drive.
iii) Case Sensitivity: Linux file system is case sensitive. It distinguishes between lowercase and uppercase file names. Such as, there is a difference between test.txt and Test.txt in Linux. This rule is also applied for directories and Linux commands.
iv) File Extensions: In Linux, a file may have the extension '.txt,' but it is not necessary that a file should have a file extension. While working with Shell, it creates some problems for the beginners to differentiate between files and directories. If we use the graphical file manager, it symbolizes the files and folders.
v) Hidden files: Linux distinguishes between standard files and hidden files, mostly the configuration files are hidden in Linux OS. Usually, we don't need to access or read the hidden files. The hidden files in Linux are represented by a dot (.) before the file name (e.g., .ignore). To access the files, we need to change the view in the file manager or need to use a specific command in the shell.

Types of Linux File System: 
- When we install the Linux operating system, Linux offers many file systems such as Ext, Ext2, Ext3, Ext4, JFS, ReiserFS, XFS, btrfs, and swap, as shown in below image;
https://static.javatpoint.com/linux/images/linux-file-system2.png
Let's understand each of these file systems in detail:

1. Ext, Ext2, Ext3 and Ext4 file system: 
> The file system Ext stands for Extended File System. It was primarily developed for MINIX OS. The Ext file system is an older version, and is no longer used due to some limitations.
> Ext2 is the first Linux file system that allows managing two terabytes of data. Ext3 is developed through Ext2; it is an upgraded version of Ext2 and contains backward compatibility. The major drawback of Ext3 is that it does not support servers because this file system does not support file recovery and disk snapshot.
> Ext4 file system is the faster file system among all the Ext file systems. It is a very compatible option for the SSD (solid-state drive) disks, and it is the default file system in Linux distribution.

2. JFS File System:
JFS stands for Journaled File System, and it is developed by IBM for AIX Unix. It is an alternative to the Ext file system. It can also be used in place of Ext4, where stability is needed with few resources. It is a handy file system when CPU power is limited.

3. ReiserFS File System:
ReiserFS is an alternative to the Ext3 file system. It has improved performance and advanced features. In the earlier time, the ReiserFS was used as the default file system in SUSE Linux, but later it has changed some policies, so SUSE returned to Ext3. This file system dynamically supports the file extension, but it has some drawbacks in performance.

4. XFS File System:
XFS file system was considered as high-speed JFS, which is developed for parallel I/O processing. NASA still using this file system with its high storage server (300+ Terabyte server).

5. Btrfs File System:
Btrfs stands for the B tree file system. It is used for fault tolerance, repair system, fun administration, extensive storage configuration, and more. It is not a good suit for the production system.

6. Swap File System:
The swap file system is used for memory paging (Paging is a function of memory management where a computer will store and retrieve data from a device's secondary storage to the primary storage. Memory management is a crucial aspect of any computing device, and paging specifically is important to the implementation of virtual memory.) in Linux operating system during the system hibernation. A system that never goes in hibernate state is required to have swap space equal to its RAM size.

Q) What is Mounting in the Linux Filesystem?
A) In Linux, the "to mount", a filesystem term, refers to the initial days of computing when a removable disk or tape pack would physically need to be mounted on a correct drive device. On the disk pack, the filesystem would logically be mounted by the OS to make contents available to access by application programs, OS, and users after being located on the drive physically.

- Simply, a mount point ( https://www.techtarget.com/whatis/definition/mount-point A mount point is a directory on a file system that is logically linked to another file system. Mount points are used to make the data on a different physical storage drive easily available in a folder structure. Mount points are fundamental to Unix, Linux and macOS. Windows can use mount points, but it is not common.
) is a directory that's made as a component of the filesystem. For instance, the home filesystem is placed on the /home directory. Filesystems can be placed on mount points on many non-root filesystems, but it's less common.

- The root filesystem of Linux is mounted on the / directory (root directory) very early inside the boot sequence.
Several filesystems are later mounted by the start-up programs of Linux, either rc upon SystemV or via systemd in new Linux versions.
- Filesystem mounting during startup is handled by the configuration file, i.e., /etc/fstab.
An easy way to understand that is fstab is short for "file system table", and it's a filesystem list that is to be mounted, their options, and designated mount points that may be required for particular filesystems.
Filesystems can be mounted on an available mount point/directory with the help of the mount command. In other words, any directory that's applied as a mount point shouldn't have other files in it and should be empty. Linux will not avoid users from mounting a filesystem on one that's already available or on a directory that includes files. The actual contents will be covered, and just the freshly mounted filesystem content will be visible if we mount any filesystem on any existing filesystem or directory.
----------------
Linux Create File: 
Linux file system considers everything as a file in Linux; whether it is text file images, partitions, compiled programs, directories, or hardware devices. If it is not a file, then it must be a process. To manage the data, it forms a tree structure.

Linux files are case sensitive, so test.txt and Test.txt will be considered as two different files. There are multiple ways to create a file in Linux. Some conventional methods are as follows:
	using cat command
	using touch command
	using redirect '>' symbol
	using echo command
	using printf command
	using a different text editor like vim, nano, vi
Ref: https://www.javatpoint.com/linux-create-file
--------------
Linux file command:
- file command is used to determine the file type. It does not care about the extension used for file. It simply uses file command and tell us the file type. It has several options.
Syntax: file <filename>  
Example: file 1.png  
Note: File command tell us the file type with the help of a magic file that contains all the patterns to recognize a file type. Path of magic file is /usr/share/file/magic. For more information enter the command 'man 5 magic'.

Linux File Command Options:
-----------------------------------------------------------------------------------------------------------------
Option	                |      			Function
-----------------------------------------------------------------------------------------------------------------
file -s			        |  Used for special files.
file *			        |  Used to list types of all the files.
file /directory name/*	|  Used to list types of all the files from mentioned directory.
file [range]*	        | It will list out all the files starting from the alphabet present within the given range.
-----------------------------------------------------------------------------------------------------------------
Touch Command in Linux/Unix with Examples: 
- touch command is a way to create empty files (there are some other mehtods also). You can update the modification and access time of each file with the help of touch command.
> It is the same as opening or creating a file and storing it without any notification to the file contents in its default usage.
> The touch command ignores closing, saving, and opening the file. Rather it updates the dates related to the directory or file.
> An updated modification or access date can be important for a range of other programs like backup utilities or make command-line interface programming utilities.
> These programs are typically only focused on files which have been modified or created after the program was last executed.
> Also, the touch command can be helpful to quickly create files for scripts or programs that need a file with a particular name to be available for successful program operation but don't need the file to include any specific content.
- SUS (Single Unix Specification) defines that the touch command should modify the modification times, access times, or both for the files. The file is recognized by a pathname imported as one argument. Also, it represents that if the file recognized doesn't exist, the file is made, and the modification and access times are fixed as specified. The touch command applies the current time if new timestamps are not specified.

Working of touch in Ubuntu:
- touch is a common Linux command to make an empty file or modify the file timestamps (file access time, last date, or modification).
Timestamps :
- Linux files contain three timestamps: ctime, mtime, and atime. These timestamps are explained below:
> atime: It includes details on when the content of the file is read with commands or tools to show the content of the file like head, grep, cat, vim, vi, nano, less, etc. The atime timestamp modifies and is updated each time it is checked.
> mtime: It displays the last modification of the content of a file, such as its name, but only the file itself, not its permission or owner.
> ctime: Also, ctime represents when any file is changed, but it is also updated if the permission, group, or ownership access on any file is modified. We can edit the mtime and atime, but we can not modify the ctime. The time will be updated if the permissions of a file are modified or if the files are modified or read.
Syntax: touch <filename>  
Example: touch myfile1 
		 touch myfile1 myfile2  # To create multiple files.

touch Options :
----------------------------------------------------------------------------------------------------
Option	                  |              Function
----------------------------------------------------------------------------------------------------
touch -a				  |   To change file access and modification time.
touch -m	              |   It is used to only modify time of a file.
touch -r	              |   To update time of one file with reference to the other file.
touch -t	              |   To create a file by specifying the time.
touch -c	              |   It does't create n empty file.
-d=, --date=	          |   This option is used to modify the timestamp with a date string.
-h, --no-dereference	  |   It modifies the timestamp of a symbolic link.
-f No effect.	          |   The option forces modifications in older BSD.
--version, -v	          |   It shows the program version.
--help	                  |   It shows the help menu.
--------------------------------------------------------------------------------------------------------
Ref: https://www.javatpoint.com/linux-touch
----------
Linux rm | Linux Delete File: 
The 'rm' means remove. This command is used to remove a file. The command line doesn't have a recycle bin or trash unlike other GUI's to recover the files. Hence, be very much careful while using this command. Once you have deleted a file, it is removed permanently.

Introduction to rm: 
rm is a general command in Unix and other Unix-like systems. It is used to delete objects like symbolic links, directories, and computer files from the file systems. Also, it removes some special files like sockets, pipes, and devices nodes, the same as the del command in Microsoft Windows, OS/2, and MS-DOS. The command is available inside the EFI shell as well.

Overview of rm:
The rm command deletes object references from the file system with the help of the unlink system call, in which the objects might have had two or more references (e.g., a file using two names), and the objects are removed themselves only if every reference has been deleted and the programs still have not been open handles for the objects.
- It permits scenarios in which a program can launch a file, remove it immediately from the file system, and use it for limited space, knowing the space of the file will be recovered after the program dismisses, even when it dismisses by crashing.
- Generally, the command doesn't damage file data because its aim is really hard to unlink references. Besides, the freed file system space may still include leftover data using the deleted file. It can be a security consideration in a few cases, and hardened releases sometimes allow to wipe out of the data because the last link is cut, and programs like srm and shred are available specifically to give data wiping features.
- The rm command is only found on Unix-derived OSes, which typically don't allow recovery of removed files using a method, such as the recycle bin, so the habit of the users to enclose the rm command is a type of wrapper to restrict unintentional file deletion.
- Also, there are some undelete utilities that will try to recreate the index and if the parts are not reused, it can get the file back.

Syntax: rm <filename>  
> The rm command removes the file named after options are included. Users can utilize a relative path or a complete path of the file to name the files to remove. The rm command does not, by default, remove a directory. The rm foo command removes the "foo" file in the current directory of the user.

> The rm command can be covered by a shell alias function of the rm -i command so as to ignore accidental file deletion. Still, if a user wants to remove a lot of files without approval, they can set the -i flag by including the -f flag manually. This approach, unfortunately, produces dangerous habits for wildcard usage, causing its accidental removal version.

> The rm -rf command is often used in anecdotes and jokes about Unix disasters, including the loss of several files during the creation of the film Pixar and Toy Story 2. The rm -rf / version of the command would lead all files accessible using the current file system to be removed through the machine if executed by a superuser.

> On the parent directory, removing a file needs the write permission on most file systems. To remove a directory, one must recursively remove each of its content. It needs that one must recursively contain the execute and write permissions for that directory and the non-empty directory. The read permissions are required to specify the directory contents to remove them. Sometimes, it causes a weird situation in which a non-empty directory can't be removed as one does not have the write permission, so one can't remove its contents; although if a similar directory was empty, one could remove it.

Example: rm myfile1  

rm Options:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Option								| 					Description
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
rm *extension						|	Used to delete files having same extension.
rm -r or R							|	To delete a directory recursively.
rm -i								|	Remove a file interactively.
rm -rf								|	Remove a directory forcefully.
-f	-f stands for force. 			|	It ignores files that do not exist and overrides the confirmation prompts. However, it will not delete files through a directory when it is write-protected.
-v	-v stands for verbose. 			|	It prints what the rm command is doing in the terminal.
-d	-d stands for directory.		|	It removes an empty directory and works only if the named directory is empty.
--one-file-system					|	It only deletes files on a similar file system like the argument and will avoid the mounted file system.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
cp Command in Linux/Unix | Linux Copy File : 
'cp' means copy. 'cp' command is used to copy a file or a directory.

Introduction to cp Command :
- The cp command is used to copy directories and files. The command contains three primary operation modes, represented by the argument types shown to the program to copy a file to other files, multiple files to any directory, or to copy the whole directories to other directories.
- Further, the utility accepts several command-line option flags for detailing the operations implemented. The two primary specifications are GNU cp and POSIX cp. GNU cp contains various extra options on the POSIX version. Also, the command is available within the EFI shell.

Operating Modes of cp command :
The cp command contains three primary operating modes. These modes are completed from the count and type of arguments shown to the program under invocation.
> The program can copy the first file's contents to the second file, making the second file if essential when the program contains two path name arguments to files.
> The program can copy all source files to the desired directory, making any file not already available when the program contains one or more path name arguments of files and pursuing those a path argument to a directory.
> The cp command can copy every file inside the source directory to the desired directory, making any directories or files required when the arguments of the program are the path names for two directories. This operation mode needs an extra option flag to represent the recursive directory's copying. The source will be copied into the destination, while a fresh directory is made if the destination doesn't exist if the destination directory is already available.
Options of cp Command:
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Option									|													Description
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--archive, -a							|		It is equivalent to the -dR --preserve=all.
--attributes-only						|		It doesn't copy the data of the file, only the attributes.
-b										|		It is like backup but doesn't accept any argument.
--backup[=CONTROL]						|		It makes a backup of all existing destination files.
--copy-contents							|		When recursive, it copies special file contents.
-d										|		It is equivalent to --no-dereference --preserve=links.
--force, -f								|		If any existing destination file can't be opened, delete it and attempt again (this option is avoided if the -n flag is used as well).
--interactive, -i						|		It asks for confirmation before overwriting (overrides the previous -n flag).
-H										|		In SOURCE, it follows the command-line symbolic links.
--link, -l								|		It specifies hard link files rather than copying.
--dereference, -L						|		In SOURCE, it always follows symbolic links.
--no-clobber, -n						|		It doesn't overwrite any existing file (overrides the -i flag).
--no-dereference, -P					|		In SOURCE, it never follows symbolic links.
-p										|		It is equivalent to --preserve=mode, timestamps, ownership.
--preserve[=ATTR_LIST]					|		It preserves the described attributes. If possible extra attributes: all, xattr, links, context.
--no-preserve=ATTR_LIST					|		It doesn't preserve the described attributes.
--parents								|		Under the directory, it uses the full source file name.
--recursive, -r, -R						|		It recursively copies directories.
--reflink[=WHEN]						|		It controls CoW/clone copies.
--remove-destination					|		It removes all existing destination files before trying to open them (opposed to --force).
--sparse=WHEN							|		It controls the establishment of sparse files.
--string-trailing-slashes				|		It removes the trailing slashes from all SOURCE arguments.
--symbolic-link, -s						|		It makes symbolic links rather than copying.
--suffix=SUFFIX, -S						|		It overrides the common backup suffix.
--target-directory=DIRECTORY, -t		|		It copies every SOURCE argument to DIRECTORY.
--no-target-directory, -T				|		It considers DEST as a general file.
--update, -u							|		It copies if the SOURCE file is newer as compared to the destination file or if the destination file is not specified.
--verbose, -v							|		It specifies what is being done.
--one-file-system, -x					|		It stays on the file system.
-Z										|		It sets the destination file's SELinux security context to the default type.
--context[=CTX]							|		It is the same as -Z, or if CTX is mentioned, it sets the SMACK or SELinux security context to CTX.
--help									|		It shows the help menu and exits.
--version								|		It provides version details and exits.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
The sparse SOURCE files are found by a cheap heuristic, and the related DESR file is created sparse by default. It is the behavior chosen by --sparse=auto. We can describe --sparse=always to make a sparse DEST file if the SOURCE file includes a long enough order of zero bytes. We can also apply --sparse=never to constrain the establishment of sparse files.

If --reflink[=always] is mentioned, implement a lightweight copy, in which the data blocks have been copied only if changed. If it's not possible or --reflink=auto is mentioned, the copy fails and falls back to the standard copy. We can also apply --reflink=never to guarantee a standard copy is implemented.

	To copy a file into the same directory syntax will be,

		cp <existing file name> <new file name>

To copy a file in a different directory: 
We have to mention the path of the destination directory.
In the snapshot below, earlier there is no 'text' file. After giving the command, 'text' file has been copied to the destination directory that is 'Desktop'.		

Linux cp -r :
> Option 'r' with the copy command can be used to copy a directory including all its content from a source directory to the destination directory.

Syntax: cp -r <sourceDirectory> <destinationDirectory>  
Example: cp -r library /home/sssit/Documents  

Linux Copy Multiple Files or Directories:
> Multiple files or directories can be copied to a destination directory at once. In this case, target must be a directory. To copy multiple files you can use wildcards (cp *.extension) having same pattern.
Syntax: cp *.<extension> <destinationDirectory>  
Example: cp *.txt /home/sssit/Documents  

Linux cp --backup: 
> If the file you want to copy already exists in the destination directory, you can backup your existing file with the use of this command.
Syntax: cp --backup <filename> <destinationDirectory>  
Example: cp --backup file2.txt /home/sssit/Downloads  

Linux cp -i :
> The cp '-i' option allows you to confirm once before overwriting your file.
Syntax: cp -i <filename> <destinationDirectory>  
Example: cp -i file3.txt /home/sssit/Desktop  

Linux cp -l: 
> If you want to create a hard link of a file instead of copying that file, you can use option 'l'.
- HardLink: A hard link is a type of link used in file systems that allows multiple directory entries (filenames) to refer to the same physical data on disk. In other words, a hard link creates multiple references or names for the same file or inode ( index node), which is the data structure that stores file attributes and data block locations on disk.
- Hard links are a fundamental concept in Unix-like operating systems, and they play a significant role in optimizing file system operations and managing file references efficiently. They are different from symbolic links (soft links) in that they directly reference the inode and its data, whereas symbolic links are separate files that point to another file by its pathname.
> Note: In creating hard link of the file the inode number of the two files will remain same. While in case of copying, inode number changes.
Syntax: cp -l <filename> <destinationDirectory>  
Example: cp -l file1.txt usr/  

Linux cp -p: 
The cp '-p' option is used to preserve the properties and attributes of a file. You can also preserve the selected properties which you want.
Syntax: cp -p <filename> <destinationDirectory>  
Example: cp -p file2.txt usr/  
Now, you can match the two files (original one and the copied one) in the above picture, both have the same properties.

Linux cp -u -v :
The cp -u -v command is used when you want to make sure that destination file is missing or doesn't exist.
Syntax: cp -u -v <filenames> <destinationDirectory>  
Example: cp -u -v docc file1.txt /home/sssit/Downloads/ 
> Giving the command 'cp -u -v' will automatically take care of the already existing file (file1.txt) and will not over write it.
> This command is useful in copying big files.
--------
mv Command in Linux/Unix with Examples :
> Linux mv command is used to move existing file or directory from one location to another. It is also used to rename a file or directory. If you want to rename a single directory or file then 'mv' option will be better to use.
a) Move a File :
> While moving a file the inode number of both the files will remain the same.
b) Move a Directory :
> Directories can be moved in the same way as the files. In this case also inode number will remain the same.

mv Option: 
-------------------------------------------------------------
Option	     |         Function
-------------------------------------------------------------
mv -i	     |  Asks for permission to over write.
mv *	     |  Move multiple files to a specific directory.
mv --suffix	 |  Used to take backup before over writing.
mv -u	     |  Only move those files that doesn't exist.
---------------------------------------------------------------
---
Linux rename:
Q) How to Rename File and Directory in Linux?
A) To rename a file there are other commands also like 'mv'. But 'rename' command is slightly advanced then others. This command will be rarely used and it works differently on different distros of linux. We'll work on Debian/Ubuntu examples.
- Generally, renaming is not a big task, but when you want to rename a large group of files at once then it will be difficult to rename it with 'mv' command. In these cases, it is adviced to use 'rename' command. It can convert upper case files to lower case files and vice versa and cn overwrite files using perl expressions. This command is a part of perl script.

Basic syntax: rename 's/old-name/new-name/' files  
This ('s/old-name/new-name/') is the PCRE (perl compatible regular expression) which denotes files to rename and how.
with above we can converted all the files ending with '.txt' into files ending with '.pdf'.

rename option:
> rename has some optional arguments but a mandatory perl expression that comes with every opption and guides it how to work.
---------------------------------------------------------------------------------
Option								|					Function
---------------------------------------------------------------------------------
rename -n							|	Check changes before running the command.
rename -v							|	Print the output.
rename (a-z)(A-Z)/ (A-Z)(a-z)		|	Convert into upper case/lower case.
rename -f							|	Forcefully over write existing files.
---------------------------------------------------------------------------------

Renaming Files using the mv Command :
> mv is a command of Unix that moves one or multiple directories or files from one position to another. If filenames are on a similar filesystem, it provides a general file rename. The content of the file is copied to the fresh location, and the previous file is deleted. Using the mv command needs the user to contain write permission for directories the file would move between. It is due to the mv command modifying both directory's content (the target and the source) involved in the moving process. When using mv on files positioned on a similar filesystem, the timestamp of the file is not updated.

Options of the mv Command: 
Most mv versions support:
a) -i: It specifies an interactive process and specifies a prompt on standard error before going to move a file that will overwrite an old file. The move is initiated if the response through the standard input starts with the 'Y' or 'y' character.
b) -f: It stands for force. In this option, force can overwrite the destination.
The above options are an element of the X/Open Portability Guidelines, later the SUS and POSIX basis. Every POSIX-compliant implementation of mv must support the same.

The syntax of mv is mentioned below: mv [OPTIONS] source destination  

> The destination can be one directory or file, and the source can be one or multiple directories or files.
> The destination should be a directory if we specify two or more files as the source. In this situation, the source files are carried to the target directory.
> The destination target is an old directory; if we specify one file as the source, then the file is carried to the specified directory.
> We need to specify one file as the source and one file as a destination target to rename any file.
For instance, to rename the myfile1.txt file as myfile2.txt, we would execute the below command:
			$ mv myfile1.txt myfile2.txt  
			
Rename multiple files using the mv command: 

The below example displays how to apply Bash for loop for renaming every file in our current directory by modifying their extensions:
for f in *.html; do  
mv -- "$f" "${f%>html}.php"  
done 
 
Let's explain the code step-by-step:
> The initial line establishes a for loop and repeats from a list of every file edging with the .html extension.
> The second line uses on all list items and carries the file to a fresh one substituting .php and .html. The ${f%>html}.php part is utilizing the shell parameter expansion to delete the .html part through the filename.
> done represents the completion of the loop segment.

Rename command: 
> Two rename command versions are available with different syntaxes. If we don't have it installed on our system, we can install it easily with the package manager of our distribution:
Installing rename on Debian and Ubuntu
		$ sudo apt install rename  
The following are some more basic examples of how to implement the rename command:
Substitute spaces in filenames using underscores:
		$ rename 'y/ /\_/' \*  
Change filenames into lowercase
		$ rename 'y/A-Z/a-z/' \*  
Change filenames into uppercase
		$ rename 'y/a-z/A-Z/' \*  

Moving versus removing and copying: 
> Moving files in a similar file system are basically implemented differently as compared to copying the file and deleting the original. A new link is included in the new directory, and the actual one is removed on platforms that don't provide support for the rename syscall. The file data is not accessed. Every POSIX-conformant system operates the rename call.
> An original move is dramatically faster as compared to the copy-and-move process. The i-number of the file doesn't change. No permission is needed for reading the file being carried insofar as it's only cataloguing data that's being modified as an outcome of the "move". Since the target and source directories are being changed, entries are being established in the target directory and removed from inside the source directory.
> In both directories, "write" permission is needed to finish the move. Carrying files from a single file system to another may entirely fail or may be performed automatically as an atomic copy-and-delete function. The original details are reliant on the implementation.
-----------------
Linux install Command: 
- Linux install command is used to copy files to a specified destination and set attributes. It copies files to a specified destination. It is not used to install programs as its name specifies. To download and install a program, we have to use apt-get, apt, yum, and more utilities, depending on the type of distribution.
- It is quite similar to the 'cp' command. Additionally, it allows us to control the attributes of the destination files. It is commonly used to copy programs into makefiles to their destination directory. It refuses to copy files on itself.
- The install command combines elements from the different commands such as cp, chown, chmod, mkdir, and strip commands. It allows us to use features of all these commands in one single action.

The features of the install command are as following:
	It is used to copy files like the cp command.
	It provides the functionality to select whether to overwrite existing files or not.
	It is used to create the destination directory if it does not exist.
	It is used to set the user permission flags of the files, like the chmod command.
	It is used to set the owner of the files.
	It is used to remove non-essential baggage from executable files.
Syntax:
install [OPTION]... [-T] SOURCE DEST  
install [OPTION]... SOURCE... DIRECTORY  
install [OPTION]... -t DIRECTORY SOURCE...  
install [OPTION]... -d DIRECTORY...  

Option:
The supported options by install command are as following:
--backup[=CONTROL]: This option creates a backup file for each existing destination file.
-b: It is like a "--backup" option, but it does not take an argument.
-C, --compare: It is used to compare each pair of source and destination files, and in some cases, it does not modify the destination at all.
-d, --directory: If the "-d or -directory" option is specified, it will treat all arguments as directory names.
-D: It is used to create all components of the target directory; after that, it copies the SOURCE to DESTINATION.
-g, --group=GROUP: It is used to set group holdings.
-m, --mode=MODE: It is used to set the permission mode (as in chmod), instead of rwxr-xr-x.
-o, --owner=OWNER: It is used to set the ownership. It can be used only by the superuser.
-p, --preserve-timestamps: It applies the access time of source file to the specified file.
-s, --strip: It is used for the strip symbol tables.
--strip-program=PROGRAM: It used to strip binaries in the program.
-S, --suffix=SUFFIX: It is used to override the usual backup suffix.
-t, --target-directory=DIRECTORY: It is used to copy all source arguments into the specified directory.
-T, --no-target-directory: It is used to treat destination file as a normal file.
-v, --verbose: It is used to print the name of each directory.
--preserve-context: It is used to preserve the SELinux security context.
-Z: It is used to set the SELinux security context of the destination file, and each created directory to default type.
--help: The '-help' option displays the help manual.
--version: It is used to display the version information.

Q) How to copy files to a directory?
A) We can customize each folder and file according to our needs by using the install command. It is used as follows:
		install -D /source/folder/*.txt /destination/folder  
From the above command, the '-D' option will copy all the text files from the source folder to the destination folder.
If you are needed to create a new destination folder, execute the below command:
		install -d /destination/New_folder  
The above command will create a 'New_folder' in the specified directory. For example, to copy two files 'Demo.txt' and 'Test.txt' to 'Downloads' directory, execute the command as follows:
		sudo install Demo.txt Test.txt Downloads  
The above command will copy the given files to the 'Downloads' folder. 
----------
Linux read Command: 
The Linux read command is used to read the contents of a line into a variable. This is a built-in command for Linux systems. Therefore, we do not need to install any additional tools. It is an easy tool to take user input when creating a bash script. It is a powerful utility and as important as echo command and positional parameter. It is used to split the words that are tied to the shell variable. Primarily, it is used to take user input but can be used to implement functions while taking input.
Syntax:
The basic syntax of the read command is as follows:
		read [options] [name...]  
Options:
a) read -p
The '-p' option is used for the prompt text. It reads the data along with some hint text. This hint text helps us while entering the text such as what to enter. Consider the below command:
		read -p " Enter your name: "  
The above command will ask for the name, enter the name. The name will store to the 'REPLY' variable. To display the variable value, execute the below command:
		echo " My name is $REPLY" 
b) read -n
The '-n' option limits the length of the character in the entered text. It will not let you enter text more than the specified number of characters. After reaching the limit of characters, it automatically stops reading. To limit the character up to six, execute the below command:
		read -n 6 -p " Enter 6 characters only: "  
The above command will not let us enter more than 6 character. 		
c) read -s
The '-s' option is used for security purpose. It is used to read the sensitive data. By using this option, the entered text won't appear in the terminal. We can use other options with this option. Characters are read in this option. Primarily, it is used to read the passwords from the keyboard. Consider the below command:
		read -s -p "Enter password: "  
The above command will prompt for the password, when we will type password, it will not be displayed on the terminal.
###################################################################################################################################################################################################################################################################

Topic6: Linux File Contents Command:

Linux File Contents Command:
There are many commands which help to look at the contents of a file. Now we'll look at some of the commands like head, tac, cat, less & more and strings.
We'll discuss about the following file contents given in the table:
-------------------------------------------------------------------------------------------------------------------------------
Commands			|				Function
-------------------------------------------------------------------------------------------------------------------------------
head				|	It displays the beginning of a file.
tail				|	It displays the last last part of a file.
cat					|	This command is versatile and multi worker.
tac					|	Opposite of cat.
more				|	Command line diaplays contents in pager form that is either in more format.
less				|	Command line diaplays contents in pager form that is either in less format.
-------------------------------------------------------------------------------------------------------------------------------
Open File in Linux: https://www.javatpoint.com/open-file-in-linux
-------
Linux Edit file: 
> Linux file system allows us to operate various operations on files like create, edit, rename, remove. We can edit files by different Linux editors like vim, nano, Emacs, Gedit, Gvim, and more.
Q) How to edit files in Linux
A) Let's understand how to edit files on a Linux server over different text editors

a)  Edit files with VI editor: 
> The VI editor is the most widely used text editor in Linux based systems. The Vi editor has various modes like normal mode, insert mode, command mode, line mode, and more. Each mode allows us to operate its specific operations.
> It is most widely used because of its modality. Most of the tools have just one mode; they take input and performs commanded operation, but Vi has several modes.
> When we start Vi, it opens with normal mode, which is basically a command mode. In this mode, whatever we type is considered as a command, not as input.
> Sometimes Vi seems like a typical editor, but when you are used to it, it will feel you like one of the powerful editing tools.
> Before editing files, let's understand how to switch a mode in Vi editor:
	Press the ESC key for normal mode.
	Press i Key for insert mode.
	Press :q! keys to exit from the editor without saving a file.
	Press :wq! Keys to save the updated file and exit from the editor.
	Press :w test.txt to save the file as test.txt
Now, let's understand how to edit a file using the Vi editor.
To edit a file, create a file first using the cat command:
		cat > Demo.txt  
The above command allows to enter the content of the file on the terminal, enter the content of the file, then press CTRL+D keys to save the file. 
To edit this file, execute the below command to open with Vi editor:
				vi Demo.txt  
The above command will open the file with the Vi editor in the normal mode. Consider the below image of the editor:

This file is open in normal mode, to switch it to insert mode press 'ESC' key followed by 'i' key. Place the cursor on your desired position and enter some text. To save the file and exit from the editor, press the 'ESC' key, followed by :wq! Keys. Consider the below image of the editor:
Now, we have successfully edited a file using the Vi editor. The editor will be closed after this and back to the command line. To see the file content, execute the cat command as follows:
				cat Demo.txt  
b) Edit files with a nano text editor:
> Nano is also one of the most used editors in Linux based systems. It is a straightforward and influential editor of Linux. It is a built-in editor for the Linux distributions. We do not need to have any prior knowledge about the nano editor before using it. In nano, no primary command is used to operate on the file. All the basic operations are displayed on the bottom of the editor. We can trigger them with a CTRL key, for example, to save the file press CTRL+O keys, to exit from the editor press CTRL+X key.
> To edit a file with the nano editor, open the file from the directory where it is stored with the following command:
			nano Demo.txt  
The above command will open the Demo.txt file with nano editor. To edit the file, move the cursor and enter the desired text and press the CTRL+O keys to save the file. Consider the below image of the nano text editor:
Press CTRL+X keys to exit from the editor. The changes you made on the file have been saved successfully. To verify the changes, execute the cat command as follows:
			cat Demo.txt  
c) Edit file using Emacs editor:
Emacs editor also allows us to edit files. Additionally, it has many built-in features such as web browser, calendar, terminal, and more. It works as a normal text editor. In Emacs editor, we can edit files and save them by navigation bar. It is not a built-in editor in Linux based system, but we can install it using the terminal.

To install emacs editor open terminal (By CTRL+ALT+T) and execute the below command:

			sudo apt-get install emacs  
To verify the updation of the file, execute the cat command as follows:
			cat Demo.txt  
-----------
Linux which command :
- The Linux which command is used to locate the executable files or location of a program from the file system. It displays the path where the specified file or command is stored.
- If you are curious to know where the specified program is stored, which command will help you to identify the path, it is quite straightforward to use.
Syntax: which <program name>  
- The above command will display the path of specified filename or command.

Options: 
- The which command facilitates with only one option that is the '-a' option. It is used to display all the paths for the specified command. In some cases, our machine contains two different paths for the same program. For example, it can be "/usr/bin/program" or "/usr/local/bin/program". The '-a' option will display both the paths for the specified command.
	Syntax: which -a <program_name>  
- Let's explore various usage of this command to better understand it:

Q) How to use which command?
A) To display the path of any executable files such as programs and commands, simply execute the which command followed by the program name.

For example, to display the path of node executable files, execute the command as follows:
		which node  
- It will display the path of node executable files.
- Which command only displays the path of executable files, so execute commands only with the arguments available in the machine. If we pass any illegal argument (which our machine doesn't contain), it will not give any output.
Which command with multiple arguments :
- We can display multiple paths of executable files by providing multiple arguments at a time in a single command. To pass the multiple arguments in which command, separate them by a space. Execute the command as follows:
		which <command1> <command2> <command3> ...  
For example, to display the path of the node, cat, ls, and mkdir command, execute the command as follows:
		which node cat ls mkdir 
- The above command will display the path for all the specified commands in a new line. 
Exit status of which command:
- The Linux user has an exit status, or it is executed by the shell script. If the exit status is 0, it means the command is successfully executed without any error. If the exit status is the non-zero number (i.e., 1 to 255), it means the command had an error and was a failure.
The which command has the following three exit status:

0: If the exit status is 0, it means all arguments are found and executable.
1: If the exit status is 1, it means one or more arguments are non-existent or non-executable.
2: If the exit status is 2, it means an invalid option is specified.

Getting help:
- If you stuck during using of which command, you can take help from your terminal by displaying the manual of the which command.
- To display the manual, execute the man command as follows:
			man which  
- To exit from the manual press 'q' key.
- We can also execute the info command to display the manual:
				info which  
- The above command will display the same output as the man command.
-------------
a) Linux head command:
- The 'head' command displays the starting content of a file. By default, it displays starting 10 lines of any file.
Syntax: head <file name>  
Example: head jtp.txt  
b) Head command for multiple files:
- If we'll write two file names then it will display first ten lines (in this case file has five lines only) of each file separated by a heading.
Syntax: head <file name> <file name>  
Example: head doc1.txt doc2.txt  
c) Linux head -n:
- The 'head -n' option displays specified number of lines.
Syntax: head -n <filename>
Example: head -15 jtp.txt
The above examples output;15 lines are displayed by the command "head -15 jtp.txt".
Note: The above example syntax can also be written as "head -n15 jtp.txt" or "head -n 15 jtp.txt". In all cases result will be same.
d) Linux head -c:
The 'head -c' command counts the number of bytes of a file.
Syntax: head -c <number> <file name>  
Example: head -c 20 jtp.txt 
Note: Bytes counting has only one syntax unlike lines counting.
- If you'll use "head -c<number>k <file name>"then it will return the result by multiplying the number by suffix. Suffix can be "b (bytes=512), k(kilobytes=1024) and m (megabytes=1048576)".
-----------
Linux tail command: https://www.javatpoint.com/linux-tail
- Linux tail command is used to display the last ten lines of one or more files. Its main purpose is to read the error message. By default, it displays the last ten lines of a file. Additionally, it is used to monitor the file changes in real-time. It is a complementary command of the head command.

Introduction to tail: 
- By default, the tail command shows the file contents. The display starts at a line, 512-byte block, or block location inside the input. Numbers that include a leading plus symbol are associated with the start of the input, e.g., "-c +2" begins the display on the second input byte. Numbers that include a leading minus or no explicit symbol are associated with the completion of the input, e.g., "-n 2" shows the last two input lines. "-n 10" or the last ten input lines are the default beginning location.
- The tail command copies the specified file to the stdout start at a designated location. The stdin is copied if the file is not specified. Copying starts at the +number position measured from the start or -number from the completion of the input. The number is measured in bytes, 1K blocks, or lines, according to the b, c, or l appended flags. -101 is the default.
- Further, the r flag leads the tail command to display lines from the completion of the file reversely. The f flag leads the tail command to keep watching and displaying further data as it shows after printing to the completion.

Syntax: tail <file name> 

File monitoring:
The tail command has two unique line options -F and -f that permits a file to be managed. Rather than just showing some last lines and closing, the tail command shows the lines and audits the file. The tail command can update the display because new lines are included in the file by other processes.
Particularly, it is helpful for auditing log files.

Default behavior:
- The default use of the tail command displays the last ten lines of the files. Create a file 'num.txt' having numbers 1 to 15 (each number in a new line).
- Let's open it by executing the tail command without any arguments as follows:
				tail num.txt 
				
Options of tail:
--block=number, -b number: number 512-byte block is the location.
--bytes=number, -c number: number byte is the location.
-f: This option leads the tail command not to stop if the file's end is reached, but instead of waiting for other data to be added to the input. The option is avoided when stdin is a pipe, but not when it's a FIFO.
-F: This option signifies the -f flag, but the tail command will also find if the followed file has been rotated or renamed. The file is sealed and re-opened if the tail command finds that the filename is read from includes the numbers of a new inode.

The tail command will keep searching and will show the file from the start when and if it's created, if the followed file doesn't become available, or if it's removed. The -F option is similar to the -f option when reading from stdin instead of a file.

--lines=number, -n number: number line is the location.
-q: The -q option is used to suppress header printing if two or more files are being monitored.
-r: The -r option leads the input to be shown by the line in reverse order. This option additionally modifies the meaning of the -n, -b, and -c options. If the -r option is named, these options define the total number of the 512-byte blocks, lines, or bytes to show rather than the bytes, blocks, or lines from the start or completion of the input through which to start the display. For -r, the default is to show every input.
All files are preceded by the header composed of the "==> XXX <==" string, in which XXX is the file name unless the -q option is specified if more than one file is specified.

Display the specific number of Lines: 
The '-n' option displays the specified number of lines. To specify the number of lines, execute the command as follows:
			tail -n <number> <file name>  
It will display the specified number of lines from the last. 

Display the specified number of bytes:
The '-c' option displays the specified number of bytes from the last. To display the specified number of bytes, execute the command as follows:
			tail -c <number> <file name>  
It will display the specified number of bytes. 

We can also use the suffix with the number such as b, kb, k, MB, and more to specify the number of bytes. These suffixes multiplied the specified number as:

b: multiplies it by 512.

kb: multiplies it by 1000.

k: multiplies it by 1024.

MB: multiplies it by 1000000.

Track a file for changes:
To track a file for changes, the '-f' option is used. Here, '-f' stands for the following. It is useful for monitoring log files. Execute the below command:
			tail -f num.txt  
The above command will monitor the file 'num.txt'. To exit from monitoring, press "CTRL+C" keys.

Display multiple files:
We can display multiple files from last at once by executing the tail command. To display the multiple files, provide the file names as input. It will display the last ten lines of specified files.
- For example, we have another file 'alphabet.txt' that contains every character of the alphabet in a new line. To display both files 'num.txt' and 'alphabet.txt,' execute the command as follows:
			tail num.txt alphabet.txt  
The above command will display the last ten lines of the specified files. 

Tail with other commands:
The tail command can be used with other commands. It can be piped to other commands to filter the output. Consider the below command:
			ls -t /etc | tail -n 6  
From the above command, we have piped the tail command with the ls command. It will only display six files or folders modified the longest time ago.
Let's execute the tail command with ps command to display the top running process. Execute the command as follows:
			ps aux | sort -nk +3 | tail -2  
----------------
Cat Command in Linux/Unix with Examples :
- The 'cat' command is the most universal and powerful tool. It is considered to be one of the most frequently used commands. It can be used to display the content of a file, copy content from one file to another, concatenate the contents of multiple files, display the line number, display $ at the end of the line, etc.
- Cat can be described as a standard Unix utility that sequentially reads files, writing them on the standard output. The name is derived from the function to catenate files. It has been shipped to several operating systems. This command is used to concatenate files which include multiple files into one file.

Options in the cat Command:
--show-all, -A: It is the same as -vET.
--number-nonblank, -b: It shows the total non-empty output lines. Also, it overrides -n.
-e: It is the same as -vE.
--show-ends, -E: It shows the $ symbol at the completion of all lines.
--number, -n: It gives the total of every output line.
--squeeze-blank, -s: It suppresses redundant empty output lines.
-t: It is the same as -vT.
--show-tabs, -T: It shows TAB characters as ^|.
-u: ignored.
--show-nonprinting, -v: It uses M- and ^ notation, except TAB and LFD.
--version: It displays the information of the output version and exit.
--help: It shows the help menu and exit.

Linux cat command: to display file content:
The 'cat' command can be used to display the content of a file.
Syntax: cat <fileName>  
Example: cat jtp.txt  
Note: To display the content of multiple files at once, type file names in one single line like "cat file1 file2 file3... fileN.

Linux cat command usage: 
----------------------------------------------------------------------------------------------------------------
Option											|		Function
----------------------------------------------------------------------------------------------------------------
cat > [fileName]								|	To create a file.
cat [oldfile] > [newfile]						|	To copy content from older to new file.
cat [file1 file2 and so on] > [new file name]	|	To concatenate contents of multiple files into one.
cat -n/cat -b [fileName]						|	To display line numbers.
cat -e [fileName]								|	To display $ character at the end of each line.
cat [fileName] <<EOF							|	Used as page end marker.
----------------------------------------------------------------------------------------------------------------
Linux cat command (to create a file): 
> The 'cat' command can be used to create a new file with greater than sign (>).
Syntax: cat > <file name>  
Example: cat > javatpoint  

To Append the Content of A File:
> The 'cat' command with double greater than sign (>>) append (add something in the last of a file) something in your already existing file.
Syntax: cat >> (file name)  
Example: cat >> javatpoint 

Linux cat command (to copy file): 
> The 'cat' command can be used to copy the content of a file into another file.
Syntax: cat (older file name) > (newer file name)  
Example: cat combo > combo2  

Linux cat command (to concatenate files) :
> The 'cat' command can be used to concatenate the contents of multiple files in a single new file.
Syntax: cat <filename1> <filename2>....  > <newFilename>  
Example: cat file1 file2 file3 > combo 

To Insert A New Line: 
> A new line will be inserted while concatenating multiple files by using a hyphen (-).
syntax: cat - <filename1> <filename2>.... > <new filename>  
Example: cat - file1 file2 file3 >combo  
Note: Line will be inserted at the beginning of the file only.

Linux cat -n command (to display line numbers) :
> The 'cat -n' option displays line numbers in front of each line in a file.
Syntax: cat -n <fileName>  
Example: cat -n jtp.txt  
	cat -b (file name) :The 'cat -b' option removes the empty lines.
		Syntax: cat -b (file name)  
		Example: cat -b jtp.txt  

Linux cat -e command (to display $):
> The 'cat-e' option displays a '$' sign at the end of every line.
Syntax: cat -e <fileName>  
Example: cat -e program

Linux cat command (as an end marker):
> The 'cat << EOF ' option displays an end marker at the end of a file. It is called here directive and file content will be saved at the given end marker.
> The file can be saved with the help of 'ctrl + d ' keys also. It works like the end marker.
Note: Any word other than 'EOF' can be used for the end marker.
Syntax: cat << EOF  
Example: cat > exm.txt << EOF  

Linux Cat Filters:
> When cat command is used inside pipes, it does nothing except moving stdin to stout.
Syntax: cat <fileName> | cat or tac |  cat or tac |...  
Example: cat weeks.txt | tac | cat | cat | tac 

Show All File Contents:
- The basic usage of the cat command is showing the file contents. Simply, we need to type "cat" followed by the filename to show the file contents using the terminal window:
	$ cat [filename]  
We can apply the wildcard character along with the cat command to show every file in the current directory:
	$ cat *  
To show only the contents of a text file inside a directory, we can type the below command:
	$ cat *.txt  
	
Show Multiple Files :
Also, we can combine and show multiple file contents together inside the terminal window with the help of the cat command. We can use the below syntax to simultaneously show multiple files:
	$ cat sample.txt test.txt  
Copy the Result of a File to Another
The cat command can also be used to copy the result of a file to another. First, it creates it if not found. It overwrites the desired file otherwise. We can use the below syntax to copy the result of a file to another:
	$ cat [source_file] > [destination_file]  
Append the Result of One File to Another
Rather than overwriting the result of a desired file in the old example, we can also use the cat command for appending the result:
	$ cat [source_file] >> [destination_file]  
If the destination file doesn't exist, it creates it. It appends the result otherwise.

Sort the Result
Also, we can merge the sort using the cat command for alphabetically sorting the result:
	$ cat example.txt | sort  
----------
Linux tac command: 
The 'tac' command is the reverse of the 'cat' command. It is also known as 'cat' backward. It will display the file content in reverse order. It prints the last line first, then second last and so on. Such way, it prints the first line at last.
Syntax: tac <file name>  
Example: tac count  

To Separate The Content: 
The 'tac --separator' command will separate the content from the mentioned string or keyword from the rest of the file content.
Syntax: tac <file name> --separator "<string>"  
Example:
tac count --separator "two"  
tac count --separator "five"  
tac count --separator "one"  
-----------
Linux more command: 
- As 'cat' command displays the file content. Same way 'more' command also displays the content of a file. Only difference is that, in case of larger files, 'cat' command output will scroll off your screen while 'more' command displays output one screenful at a time.
Following keys are used in 'more' command to scroll the page:
	Enter key: To scroll down page line by line.
	Space bar: To go to next page.
	b key: To go to the backward page.
	/ key: Lets you search the string.
Syntax: more <file name> 
Example: more /var/log/udev  

Linux more options: 
-------------------------------------------------------------------------------------------
Options					|			Function
-------------------------------------------------------------------------------------------
more -num				|	Limits the line displayed per page.
more -d					|	Displays user message at right corner.
more -s					|	Squeeze blank lines.
more +/string name		|	It helps to find the string.
more +num				|	Used to display the content from a specific line.
-------------------------------------------------------------------------------------------
Note: The 'more' command can't be used to display binary files.
-----------------
Linux less command:
- The 'less' command is same as 'more' command but include some more features.
- It automatically adjust with the width and height of the teminal window, while 'more' command cuts the content as the width of the terminal window get shorter.
Syntax: less <file name>  
Example: less /var/log/udev  

Linux To Find A String: 
- A particular string is searched by typing forward slash (/) and then followed by the string name, at place of file name in the lower left corner of the terminal box.
Syntax: /string name  
Example: /add  

less Command Navigation Keys: 
- The 'less' command have navigation keys similar to the 'vim' editor. Let's have a look on some of the navigation keys and other operations of less command.

1. Search Navigation
search navigtion keys will help you in forward and backward search.

a) Forward search: 
/ : search for a pattern for the next occurence
n : search for next match
N : search for previous match

b) Backward search:
? : search for a pattern for the next occurence
n : for next match in backward direction
N : for previous match in forward direction

c) Search path
Forward : /\/home\/sssit\/
Backward : /home/sssit

2. Screen Navigation
Ctrl + f : forwards one window
Ctrl + d : forwards half window
Ctrl + b : backwards one window
Ctrl + u : backwards half window

3. Line Navigation
- to move forward or backward line by line
j : forward by one line
k : backward by one line

4. other Navigations
G : used to go to end of the file
g : used to go to start of the file
q or ZZ : to exit

5. Count Keys
10j : 10 lines forward
10k : 10 lines backward

6. Marked Navigation
ma : mark current position with letter 'a'
a : go to marked position

7. Multiple File
- by passing arguments in the same line
	less file1 file2  
while viewing file1 go to file2
	less file1  
     :e file2  
to navigate between files when more then two files are opened
	n : go to next file
	p : go to previous file
-------------------------------
Linux strings command: 
- Linux strings command is used to return the string characters into files. It primarily focuses on determining the contents of and extracting text from the binary files (non-text file).
- It is a complex task for a human to find out text from an executable file. The binary files, such as program files, contain human-readable text. These files are large-sized if we use a cat or less command; it may cause the terminal to hang up.
- There can be two types of characters in a file; printable and non-printable. The alphanumeric characters, punctuation, or whitespaces are known as printable characters; except the printable character, all the characters are known as non-printable characters.
- In simple words, we can say that it extracts printable characters from files so that other commands can use the strings without non-printable characters.
Q) Here, the question arises why do we put text in executable files? When an application or software is deployed, most developer packages the binary files. But it is good to pack some ASCII text in the binary file. It will be helpful for the users and for the developers to understand more about the executable file.
So, the strings command is useful to determine the contents of non-text files.

Q) How to use it?
A) Use of strings command is straight forward, just pass the file name as an argument and execute it. Let's understand it with an example.
We have a system file called gyp.el. To extract the string from this file, execute the command as follows:
		strings gyp.el  
Customize the character limit: 
By default, the strings command prints only the character sequence that is at least four characters long. However, we can change this limit forcefully by using the -n option. It allows us to pass the number to signify a limit.
Example: To set the limit for two characters, execute the below command: strings -n 2 gyp.el  
Piping the limit:
In case we have a file that contains a lengthy output, we can pipe it through less. It will show less output, and we can scroll and append output as our need.
To pipe a limit through less, execute the command as follows: strings gyp.el | less  

How to look through RAM using Strings command?
The strings command is not just limited to files. It allows us to look through the RAM of our computer system. We need to use Sudo privilege because we are accessing /dev/mem, which holds the blueprint of the main memory of our system . Execute the command as follows:
		sudo strings /dev/mem | less  
		
Include Whitespaces:
- The default behavior of the strings command contains whitespace as a printable character. Therefore if we have a string, " Javatpoint is one of the best platforms To learn technology," then the strings command would return the whole text.
- It does not consider the new line characters and carriage returns as printable characters.
- To print a string that recognizes new line characters and carriage returns as a printable character, execute the command as follows:
		strings -w File_name  
Change the Encoding :
- The strings command provides four types of encoding options, which are as following:
	s: 7-bit byte (used for ASCII, ISO 8859)
	S: 8-bit byte
	b: 16-bit bigendian	
	l: 16-bit littleendian
The default option is 's'; a 7-bit byte.
We can change the encoding; to change it, execute the following command:
	strings -e S file_name  
or
	strings --encoding=S file_name  
In the above commands, we specified the encoding as 'S,' which means 8 bit-byte encoding. You can specify any of the above options, simply by replacing 'S' with the encoding letter of your choice.

Reading options from file:
If you are using the same options repeatedly, you don't need to specify each time. Instead, you can create a file and specify the options within that file.
To create a file for specifying the options, execute the below command:
		vi stringout  
The above command will open the vi editor. Here we are creating a file using vi editor; you can choose any editor of your choice.
Press ESC and 'i' keys for insert mode. Type the options that you want to specify as follows:
	-f -o -n -S  
>
After entering the option, save the file by pressing ESC and :wq! Keys.
To run the strings command with the specified options, execute the command as follows:
		strings @stringsopts gyp.el 
Getting Help:
If you stuck anywhere while using the strings command. You can take help from your terminal by using the help option. To get help, execute the below command:
	strings -help  
you can also read the manual at any time by executing the command as follows:

man strings : 
Check the Strings Version
To check the version of strings that you are using, execute one of the following commands:
	strings -v  
	strings -V  
	strings -version 
---------------------
Linux Print :
In Linux, different commands are used to print a file or output. Printing from a Linux terminal is a straightforward process. The lp and lpr commands are used to print from the terminal. And, the lpg command is used to display queued print jobs.

Printing the double-sided document or in portrait mode is a bit complicated process. And there may be many other operations that we want to perform, such as printing multiple copies or canceling a print job, which can be difficult to perform.

Ref: https://www.javatpoint.com/linux-print
########################################################################################################################################################
Topic7: Linux Process
Q) How to Kill a Process in Linux?
A) In an operating system, there are many programs that take place on computer's RAM. These programs may be run by OS itself or a user, such programs are called 'Processes.' Usually, a process has its life cycle and get terminated by its own when it is completed or when we quit it manually. But, sometimes, a process may hang up due to error in process scheduling or because of consuming a lot of RAM or CPU. In such cases, we need to kill the processes manually to save our machine from unexpected hang up.
- Linux allows various tools to kill an errant process. In order to kill a process, we must have the process information such as PID, signal, and more.
Locating the processes:
- Linux system allows us to kill a process in various ways, such as kill a process by its name or process id (PID). So, we will use the above commands according to our need.

Locating the processes by 'top' command:
The top command is used to list all the running processes in a Linux system. It displays detailed information such as PID, username, CPU usage, time, executed command, and more.
To locate the processes, execute the command as follows:
		top  
Locating the processes by ps and grep command: 
The ps command is another way to display the process information. There are many options that are used with the ps command, such as aux, which means:
	a : To display the processes for all the users
	u : To display the processes used by particular user
	x : To show all the processes. If we do not specify the x option, it will not display the GUI process.
Execute the below command to list all the running processes:
		ps aux  
NOTE: The ps command is more useful than the top command. It allows us to filter the output with grep command.
Suppose we want to filter all the process with the user name javatpo+, execute the command as follows:
		ps aux | grep javatpo+ 
		
Locating the process by pidof and pgrep command:
The pidof command also allows us to locate the process. If we want to track a process by its name, the pidof command will be very useful. It displays the PIDs of the processes when it is used with the process name.
- To locate the PID of a process, execute the pidof command as follows:
		pidof process_name  
If we have the running process with exact name chrome, execute the command as follows to get it's PIDs.
		pidof chrome  

Killing a Process:
Now as we have tracked the processes, we can kill a process. There are various commands that are used to kill a process such as kill, kill, top, and pkill.

Before killing a process, it is necessary to know what processes we can kill. Below are some essential points about killing processes:

> If you are a normal user, then you can only kill the processes that belong to you. You cannot kill the processes that are running by the other users. The top and ps aux commands display the users with the related process.
> A root user can kill all the processes. However, we can also add sudo before any command to execute it as root.
> In Linux, when a process is being killed, a special signal is transmitted to the processes. Although there are various types of signals in Linux, but in this case, Linux deals with the SIGKILLS and SIGTERM signals. By default. Linux sends the SIGTERM, which terminates the process gracefully. If you want to kill a process forcefully, use SIGKILL instead.
> Linux keeps the status of the processes until it is completely removed from the system. So, the child processes will be displayed in the process list until a parent process is deleted.
> We cannot kill a process if it is in 'uninterruptible sleep.' This situation occurs when a process performs an input/output operation. This state can be seen in the 8th column of top and ps aux command.

Killing a process by the killall command:
The killall command is the easiest technique to kill a process if you know the exact process name, it is not running by any other user, and it is not in Z or D state. In kill all command, there is no need to locate the process or PID. To kill a process, execute the command as follows:
			killall firefox  
The above command will kill the process and quit the firefox browser.

To forcefully kill the process, execute the killall command with -SIGKILL as follows: killall -SIGKILL process_name  
we can also use -9 instead of -SIGKILL.

To kill a process interactively, execute the command as follows: killall -i process_name  

To kill a process as a different user, execute the command as follows: sudo killall process_name  

We can also kill a process for a fixed time period by using -o and -y flags. To kill a process that has been running for more than 20 minutes, execute the below command: killall -o 20m process_name

To kill a process that has been running for less than 20 min, execute the below command: killall -y 20m process_name  

Abbreviations for using the time period are as following:
	seconds: s
	minutes: m
	hours: h
	days: d
	weeks: w
	months: M
	years: y

Kill a process by the pkill command: 
Sometimes we do not know the exact name of the process; in such case, the pkill command will be the most useful utility to kill a process. It allows us to kill a process by entering the matching name of the process. For example, we want to kill all the processes with matching name java, execute the command as follows:
			pkill java  
it will close all the processes that are containing name java. Similarly for killing a firefox process, execute the command as follows:
			pkill fire  
If the pkill command is successfully executed, it will not display any output.
To kill a process forcefully by pkill command, execute it as follows:
		pkill -SIGKILL process_name</p>  
		<p>we can also use -9 instead of -SIGKILL. 
		
Kill a Process by the kill command:
The kill command is the simplest utility to kill a process; all we need a PID of a process. Once we get the PID of the process, it is a straight forward process. To terminate a process, execute the kill command followed by PID. To locate the PID of a process, use the top or ps aux command, as explained above.

To kill a process having PID 5296, execute the command as follows: kill 5296  
To forcefully terminate a process, use the -SIGKILL or -9 option: kill -SIGKILL 5296  
The above command will terminate the process having PID 5296.

Kill a Process by top command
The top command allows us to locate and kill the process. It is a straightforward process to terminate a process by using top command. First, execute the top command to locate the process and press the 'k' key while the command is running.It will dive you in the process killing mode, enter the PID of the process that you want to kill.

Kill a Process by System Monitor:
We can also terminate a process by Linux's graphical environment called system monitor. To kill a process through system monitor, follow the below steps:
	Step1: Search or browse the system monitor, press enter to open it.
	Step2: It will list all the running processes of your Linux system.
	Step3: Browse the process and right-click on it that you want to terminate.
	Step4: Select the Kill option. Also, we can use the CTRL+K keys to kill it.
-----------------------
Linux Terminating:
There are four ways to kill or terminate a process. These commands allow you to run the system uninterruptedly after terminating a process without rebooting the system. These commands can be internal or external.
---------------------------------------------------------------------
Command		|		Function
---------------------------------------------------------------------
kill		|	Need to specify PID number
killall		|	Kill more than one process with a single name
pkill		|	Need to specify name of the process
xkill		|	Kill a x server client
---------------------------------------------------------------------
Q) How to know PID?
A) To use terminating commands you need to know different PIDs. PID for a process can be find out with the following command,
Syntax: ps -A  
------------
Linux kill: 
The most common command to terminate a process is kill command. You need to know the PID of the process you want to terminate.
kill command sends signal to the specified process. For sending signal either signal name or signal number can be used.
Syntax: kill -SIGNAL PID  
Common signal names and numbers:
Here is a list of some common signal names and signal numbers. Please note that these signal names and signal numbers may vary. For complete information about signals refer to the man page of the signal with command "man 5 signal" or "man 7 signal".
--------------------------------------------------------------------------------
Signal Name	|	Signal Number	|		Signal Use
--------------------------------------------------------------------------------
SIGNULL		|		0			|	NULL, check access to PID
SIGHUP		|		1			|	Hangup
SIGINT		|		2			|	Interrupt
SIGQUIT		|		3			|	Quit
SIGKILL		|		9			|	Kill
SIGTERM		|		15			|	Terminate
SIGSTOP		|		24			|	Stop
SIGTSTP		|		25			|	Stop/pause the process
SIGCONT		|		26			|	Continue a stopped process
--------------------------------------------------------------------------------

To list signal names:
To see a list of signal names in your system, following command can be used.
Syntax: kill -l  
Example: To kill a process having PID 2408, use following command
			kill -9 2408
----------------------------
Linux killall :
The killall command need the process name instead of PID. It kills all the processes with the specified name in the system.
Syntax: killall -<signal name or option> <name>  
Option: 
Command killall is case sensitive, to make it non case sensitive, use following command: killall -I
-----------
Linux pkill:
The pkill command uses name of the process instead of PID number. Signal can be send to a process either by typing full name or partial name.
While specifying partial name, the specified name should be within first 15 characters of the process name.
Example: pkill -2 sample
With above example, signal will be sent to all the process which has sample in its name.
---------------------
xkill :
Command xkill is used to kill a process on X server without passing process name or PID. It forces the X server to close the communication with its clients, which ultimately kill its clients by its X resource. In short, xkill instructs X server to terminate client.
To get a list of x clients, use command
Syntax: xlsclients  
To use xkill command
Using xkill command when you want to kill a process, type xkill on the terminal. Your cursor will change in the shape of x, click on the window which you want to kill using x cursor. You'll get the following message as shown in below snapshot.
------------------------
Nohup Command:
> The nohup stands for no hang-up, it is a Linux utility that keeps the processes running even after exiting the terminal or shell. It prevents the processes from getting the SIGHUP signals (Signal hang up); these signals are sent to the process to terminate or end a process.
> Usually, when we exit from the terminal, all the running processes are terminated by default. However, it shows a warning for the running process. If a process takes more time than expected and we need to complete it. In such cases, a nohup command is a handy tool for keep running the process in the background. The best usage of nohup commands is in memory check, synchronization, restarting a server, and more. It is also advantageous when we run a program over ssh.
> In the case of ssh connection, if a connection is interrupted, all the running processes are terminated, and we may lose our data. The nohup command overcomes this problem; it ignores all hangup signals and allows the process to continue.

Syntax:
The nohup command can be used in two ways:
	nohup command arguments  
or
	nohup options 
Checking the nohup version:
It is a default command-line utility of a Linux system. Therefore, we don't need to install it. We can check the installed version by executing the following command:
		nohup --version  
Q) How to start a process using nohup ?
A) If you want to run a process after exiting the terminal, execute the nohup command followed by the process. It is a straight forward process. The process will continue running and will not get killed.
Let's take an example to understand how nohup works. We have a file 'hello.sh,' we will open it using nohup command. Execute the below command:
	nohup cat hello.sh  
Now, the cat command will execute completely even if we close the terminal		
We can see from the above output, it will create a file 'nohup.out' and append the output to it.
To display the output, execute the below command:
		cat nohup.out  
Moreover, we can also redirect the output to a specified file. To do so, execute the command as follows:
		nohup cat hello.sh > newfile  
The above command will redirect the output to a specified file 'newfile.' To verify the output, execute the command as follows:
		cat newfile  
Starting a background process:
To start a process in the background, use the '&' symbol after the command. It will execute our process in the background. For example, if we want to ping javatpoint.com, execute the command as follows:
		nohup ping javatpoint.com &  
The above command will ping us with javatpoint.com and redirect the process to the background.To check the process, execute the pgrep command as follows:
		pgrep -a ping  
To kill the process, execute the kill command with the given PID.
		Kill 14085 14546  
-------------
Linux at command:
Linux at command is used to schedule a task to execute it once at a specified time, without editing a configuration file. It is an alternative to the cron job scheduler. It can be useful if we want to execute a process after some time, such as a shutdown system, taking backups, sending emails as reminders, and more.

The at command is capable of executing a command or script at a specified time and date, or at a given time interval. We can use minutes, hours, days, or weeks to specify the time. It also allows some keywords such as midnight or teatime (which is used for         'to 4 pm').

Note: It cannot be used for recurring tasks, for recurring tasks prefer the Linux crontab.
The atq and atrm commands are also a part of the at command. Let's understand both commands in brief.

The atq command: The atq command is used to display the user's pending tasks. If the user is a root user, it will list all the tasks. Otherwise, it will list the particular user's job. The format of displaying output is Task id, date, hour, queue, and username.
The atrm command: It is used to delete tasks, identified by their job number.

Options
Various options are supported by the 'at' command to make it more specific. The options that are facilitated with the at command are as following:
	-V: It is used to display the number to standard errors and exit successfully.
	-q: It is used to specify the queue. The queue designation consists of a letter. It ranges from a to z or A to Z. The queue is the default queue, and the b queue is used for the batch. The queues with the higher letters run with increased priority. The queue '=' is a special queue; it is reserved for the currently running jobs.
	-m: It is used to send mail to the user when the job is successfully executed. It will work if there is no output.
	-M: It is used to never send mail to the user.
	-f: It is used to read the job from the file rather than standard output.
	-t: It is used to specify the time to run a job; it will be in the format [[CC]YY]MMDDhhmm[.ss].
	-l: The -l option is an alias for the atq command.
	-r: The -r option is an alias for the atrm command.
	-d: The -d option is an alias for the atrm command.
	-b: The -b option is an alias for the batch command.
	-v: The -v option is used to display the time of the job before execution.
To use the at command, we have to install it on our system. Let's understand how to install it.

Install at command in Linux (Ubuntu):
To install at command, execute the below command:
	sudo apt-get install at  
The above command will ask for the system password, type the password, and press ENTER key. It will start a daemon process and install the at command to your machine.
Once the at command is installed, we must start and enable the atd service. To start and enable the atd service at the boot time, execute the below commands:
	systemctl start atd  
	systemctl enable atd  
The above command will start and enable the atd service.
Schedule the first task using at :
To schedule a task, execute the at command followed by the time or a keyword.
For example, to schedule the task sh back up at 10.20 pm, execute the command as follows:
	at 10.20 pm  
	warning: commands will be executed using /bin/sh  
	at> sh backup.sh  
	at> ^d  
Press CTRL+D or ^d keys to complete the task. The above command will schedule the backup.sh at 10.20 pm. 
We can also use the below command for the same process:
	echo "sh backup.sh" | at 10.20 pm  
The above command will perform the backup.sh at 10.20 pm. 

List the scheduled tasks:
We can list all the scheduled tasks by using the atq command. If we execute it from the root user, it will list all user's jobs. But, if we are not a root user, it will only list the particular user's jobs. Execute the command as follows:
		atq  
From the above output, we can see that we have scheduled only one task. It is displaying the task id, date and time, and user name, respectively.

Remove scheduled task:
We can remove a scheduled task by its task id with atrm command. To remove a scheduled job, execute the atrm command followed by job id as follows:
		atrm 2  
The above command will remove the task having task id 2. 
From the above output, we can see if a job is successfully removed, it will not display any output. To verify whether the job is successfully removed or not, execute the atq command.

Check the content of the scheduled task: 
- We can list the task by executing the atq command. But if we want to know that what script or command is scheduled, we need to execute the at command with '-c' option followed by task id. Execute the command as follows:
				at -c 2  
The above command will display the content of the task having task id 2.
Examples of the at command:
Some useful examples of the at command are as following:
Example1: Schedule task at 8:00 AM.
To schedule the task at 8:00 AM, execute the command as follows:
			at 8:00 AM  
Example2: Schedule task at 8:00 AM on the coming Tuesday.
To schedule task at 8:00 AM on coming Tuesday, execute the command as follows:
			at 8:00 AM tuesday  
Example3: Schedule task at 8:00 AM on coming 15'th of April.
To schedule a task at 8:00 AM on coming 15'th April, execute the below command:
			at 8:00 AM apr 15 
Example4: Schedule task at 8:00 AM tomorrow.
To schedule a task at 8:00 AM tomorrow, execute the below command.
		at 8:00 AM tomorrow  
Example5: Schedule tasks to execute just after 2 hours.
To schedule a task to execute just after 2 hours, execute the below command:
		at now + 2 hour  

Getting Help:
If you get stuck anywhere while using the 'at' command, you can take help from your terminal by reading the manual. To display the manual of at command, execute the man command as follows: man at  
The above command will display the manual, which contains information about the at command as well as supported options.
To read more scroll the output and to exit from the manual, press 'q' key.
----------
Linux exit command:
- Linux exit command is used to exit from the current shell. It takes a parameter as a number and exits the shell with a return of status number. If we did not provide any parameter, it would return the status of the last executed command. The exit command closes a script and exits the shell.
- If we have more than one shell tab, the exit command will close the tab where it is executed. This is a built-in command, and we cannot find a dedicated manual page for this.
Syntax: exit  
- From the above command, after pressing the ENTER key, the terminal will be closed, and all the normal running processes of the terminal will be ended.
- The exit command is the most useful common in Linux. We can pass with it many times. It uses the exit() function to terminate the normal process. Some points regarding the exit command are as following:
	It is used to exit from the shell script with an exit status N.
	It can be used to verify whether the shell script is successfully terminated or not.
	The exit status can be used by other commands to take their actions.
	If the value of N is not specified, the exit status will be the last executed command.
	The value of N is set to 0, and it stands for the normal shell exit.
Options:
The exit command does not provide many options. But, it supports the following options:
	Exit without any parameter:
If we execute it without any parameter, it simply closes the terminal. Execute it as follows: exit  
The above command will simply close the terminal.

Exit with exit status:
- If we pass a parameter, it will close and return the same exit status. For example, if we execute it with an exit status 10, it will return a status of 10. consider the below command: exit 10  
- The above command will close the terminal and return a status of 10. The return statuses are useful as some times they can be tracked to tell error. For example, the return status '0' means the program has successfully executed, and '1' means the program has minor errors.

Display the last return status:
- To display the exit status of the last executed command, execute the "echo $?" command as follows: echo $? 
- The above command will display the last returned status.

Exit status of a shell script:
Let's create a script, 'Demo.sh.' To create it, execute the following command:
		cat > Demo.sh  
		echo " This is a demo."  
		exit 0  
Save the above script by pressing the CTRL+D keys. Now, execute the script by executing the following commands:
		chmod +x Demo.sh  
		./Demo.sh  
The above command will execute the script. Now, check the exit status of the script by executing the below command:
		echo $? 
If status is 0, then it is succesfully exited.

Getting Help:
The exit command is a built-in utility. There are no dedicated manual pages available for it. However, it supports the "-help" option, which displays information about the command. To get help, execute the command as follows:
		exit --help  
The above command will display help on the command line. We can also execute the help exit command as follows:
		help exit  
Both commands will produce the same output.
####################################################################################################################################################################################################33
Topic8: Linux Filesystem Hierarchy Standard (FHS)
Linux File Hierarchy:
- Filesystem hierarchy standard describes directory structure and its content in Unix and Unix like operating system. It explains where files and directories should be located and what it should contain.
- Its current version is 3.0 released on June 3rd 2015 and is maintained by Free Standards Group. In Unix like operating system everything is considered as a file.
- Only Linux distributions follow the FHS and that too partially. Because every distro have their own policy due to which you may notice some differences in the directory tree structure of different distros.
- If you want to find out information about your system's FHS, enter the command man hier. It will display directory structure of your system.
Note: GoboLinux and NixOS doesn't follow FHS at all, it has its own and completely different policy.

The Root Directory:
> All the directories in the Linux system comes under the root directory which is represented by a forward slash (/). Everything in your system can be found under this root directory even if they are stored in different virtual or physical devices.
> Look at the above snapshot, we have shown you the root directory of our system i.e; Ubuntu with the help of the command "ls /". Here, we have written (/) to represent root directory.

Linux Directories:
We have categorize the directories according to the type of file as given below:
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Directory type				|				Types of files stored
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Binary directories			|	Contains binary or compiled source code files, eg, /bin, /sbin, etc.
Configuration directories	|	Contains configuration files of the system, eg, /etc, /boot.
Data directories			|	Stores data files, eg, /home, /root, etc.
Memory directories			|	Stores device files which doesn't take up actual hard disk space, eg, /dev, /proc, /sys.
Usr (Unix System Resources)	|	Contains sharable, read only data, eg, /usr/bin, /usr/lib, etc.
var (variable directory)	|	Contains larger size data, eg, /var/log, /var/cache, etc.
Non-standard directories	|	Directories which do not come under standard FHS, eg, lost+found, /run, etc.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------
Linux Binary Directory:
- Binary files are the files which contain compiled source code (or machine code). They are also called executable files because they can be executed on the computer.

Binary directory contains following directories:
	/bin
	/sbin
	/lib
	/opt
	
a) /bin:
- The '/bin' directory contains user binaries, executable files, Linux commands that are used in single user mode, and common commands that are used by all the users, like cat, cp, cd, ls, etc.
- The '/bin' directory doesn't contain directories.
Example: ls /bin
	command "ls /bin" displays the list of '/bin' directory. Commands like cp, cat, less, touch, etc can be seen 

b) /sbin
- The '/sbin' directory also contains executable files, but unlike '/bin' it only contains system binaries which require root privilege to perform certain tasks and are helpful for system maintenance purpose. e.g. fsck, root, init, ifconfig, etc.
Example: ls /sbin 

c) /lib
- The '/lib' directory contains shared libraries which are often used by the '/bin' and '/sbin' directories. It also contains kernel module. These filenames are identable as ld* or lib*.so.*. For example, ld-linux.so.2 and libfuse.so.2.8.6
Example: ls /lib
/lib/modules: The '/lib/modules' stores kernel modules and has a directory for each installed kernel.Modules are meant to use extra hardware support without making a new kernel.
/lib32 and /lib64: During compilation time of libraries you'll encounter through the directories named '/lib32' and '/lib64' which will clarify register size to be used. A 64-bit system may have compatibility for 32-bit binary.

d) /opt
- The term 'opt' is short for optional. Its main purpose is to store optional application software packages. Add-on applications from individual vendors should be installed in '/opt'. And so in some systems '/opt' is empty as they may not have any add-on application.
-------------
Linux Configuration Directory: 
- The configuration directory contains configured files which configures the parameters and initial settings for some computer programs.

Configuration directory have following sub-diectories:
		/boot
		/etc

a) /boot: 
- The '/boot' directory contains boot loader files which are essential to boot the system. In other words, they only contain files which are needed for a basic Linux system to get up and going.
- You may find '/boot/grub' directory which contains '/boot/grub/grub.cfg' (older system may have /boot/grub/grub.conf) which defines boot menu that is displayed before the kernel starts.
Example: ls /boot

b) /etc:
- All the machine related configurtion files are kept in '/etc'. Almost everything related to the configuration of your system is placed here. It also contain startup and shutdown shell script which is used to start and stop a program. All the files are static and text based and no binary files can be placed in this directory.
- The meaning of 'etc' is very controversial. Earlier it was referred to as 'Etcetera' because it could contain all the files that did not belong from anywhere else. But recently its most likely meaning is 'Editable Text Configuration' or 'Extended Tool chest'.
- Configuration files will have an extension of .conf.
Example: ls /etc

Some common directories of /etc are:
/etc/init.d/: The term 'init' is short for initialization. This directory contains script to control the system or to start and stop the daemons (background process). The 'init' is a daemon process that continues running until the system is shut down.
/etc/X11/: The X Window system configuration files are stored in this directory. The configuration file of graphical display (xorg.conf) is also stored here.
/etc/skel/: The term 'skel' is short for skeleton. Everything in the system has a skeleton which is called hidden file and is stored in this directory. It is not an important part in the system and can be deleted but still it serves a specific purpose. Its purpose is to serve the basic set of files, a basic framework which can be used in the creation of a new user.
------------
Linux Data directory:
- Data directory is used to store data of the system.

Data directory contains following directories.
	/home
	/root
	/srv
	/media
	/mnt
	/tmp

a) /home:
- The '/home' directory stores users personnel files. After the '/home' there is a directory which is generally named at the user's name like we have '/home/sssit'. Inside this directory we have our sub-directories like Desktop, Downloads, Documents, pictures, etc.
Example: ls /home  
		 ls /home/sssit
While command "ls /home/sssit" displays 'sssit' sub-directories.
Note: Tilde (~) sign indicates "/home/sssit". For example, if you want to give the command "/home/sssit/Desktop" so instead of writing this you can also write "~/Desktop", both are same.

b) /root:
- The '/root' directory is the home directory of the root user.
- Please note that '/root' directory is different from (/) root.

c) /srv:
- The term 'srv' is short for service. The '/srv' directory contains server specific data for services provided by the system like www, cvs, rysync, ftp, etc.

d) /media:
- The '/media' directory acts as a mount point for removable media devices such as CD-Rom, floppy, USB devices, etc.
- This is newly introduced directory and hence a system can run without this directory also.
Example: ls /media  

e) /mnt:
- The term 'mnt' stands for mount. The '/mnt' directory should be empty and sysadmins can only mount temporary filesystems.

f) /tmp:
- The term 'tmp' stands for temporary. Data stored in '/tmp' is temporary and may use either disk space or RAM. When system is rebooted, files under this directory is automatically deleted. So it is advisable that never use '/tmp' to store important data.
----------------
Linux Memory Directory:
- Memory directory contains files of the whole system. All the device information, process running indata or system related information are stored in this directory.

Memory directory contains the following directories.
		/dev
		/proc
		/sys

a) /dev:
- The term 'dev' is short for device. As you know in Linux operating system everything is a file. It appears to be an ordinary file but doesn't take up disk space. Files which are used to represent and access devices are stored here including terminal devices like usb. All the files stored in '/dev' are not related to real devices, some are related to virtual devices also.

/dev/tty and /dev/pts: The '/dev/tty' file represents the command line interface that is a terminl or console attached to the system. Typing commands in a terminal is a part of the graphical interface like Gnome or KDE, then terminal will be represented as '/dev/pts/1' (here 1 is replacable by any another number).
/dev/null: The '/dev/null' file is considered as black hole, it has unlimited storage but nothing can be retrieved from it. You can discard your unwanted output from the terminal but can't retrieve it back.

b) /proc:
- The term 'proc' is short for process. Same as '/dev', '/proc' also doesn't take up disk space. It contains process information. It is a pseudo filesystem that contains information about running processes. It also works as virtual filesystem containing text information about system resources.
/proc conversation with the kernel: The '/proc' displays view of the kernel, what the kernel manages and it is a means to directly communicate with the kernel.
Example: ls /proc 
- Also most of the files in '/proc' are of 0 bytes yet they contain a lot of data. Most of the files are readable only, some require root privileges and some are writable.
/proc/interrupts: The '/proc/interrupts' displays the interrupt.
Example: cat /proc/interrupts  

c) /sys:
The term 'sys' is short for system. Basically it contains kernel information about hardware. It was created for Linux 2.6 kernel. It is a kind of '/proc' and is used for plug and play configuration.
------------------------
Unix System Resources (/usr):
- Although it is pronounced as user but in actual it stands for Unix System Resources. It is also called secondary hierarchy as it contains binaries, libraries, documentation for all the user applications. It only contains shareable read-only data.
Example: ls /usr  
We'll explain some of the /usr sub-directories:
	/usr/bin
	/usr/include
	/usr/lib
	/usr/share
	/usr/local
	/usr/src

a) /usr/bin:
The '/usr/bin' directory contains non-essential binary commands for all users. If you can't find a command in '/bin', search it in '/usr/bin'. It contains a lot of commands.

b) /usr/include:
The '/usr/include' directory contains standard include files for C.

c) /usr/lib:
The '/usr/lib' directory contains libraries that are not directly executed by the users. In other words, it contains binaries for the '/usr/bin' and '/usr/sbin'.

d) /usr/share:
The '/usr/share' directory contains architecture independent (shared) data.

e) /usr/local:
The '/usr/local' directory is used to install software locally. It means all the user programs that you'll install from source will be installed here.

f) /usr/src:
The term 'src' is short for source. It is used to store source code like kernel source code with its header files.
------------
Variable Directory (/var):
- The term 'var' is short for varible. Files that have an unexpected size and whose content is expected to change continuously (that's why it is named as variable) during normal operation of the system are stored here. For example, log files, spool files and cache files.
Example: ls /var  

We'll explain some of the /var sub-directories here:
	/var/log
	/var/cache
	/var/spool
	/var/lib

a) /var/log:
The '/var/log' directory contains all log files.
Example: ls /var/log  
b) /var/cache
The '/var/cache' directory stores application cache data. Cache data are locally generated by I/O or calculation. Cache must be able to regenerate or restore the data. These files can be deleted without any loss of data.
Example: ls /var/cache
c) /var/spool
The '/var/spool' directory is used to spool the files waiting to be processed. For example, printing queues and mail queues.
Example: ls /var/spool  
d) /var/lib
The '/var/lib' directory stores the files that contains state information like databases. File's data modifies as their respective programs run.
------------------
Non-Standard Directories:
Directories which do not come under the standard FHS are called non-standard directories.

Non-standard directories are as follows:
		/cdrom
		/run
		/lost + found

a) /cdrom:
The '/cdrom' directory is not in the standard FHS but cdrom can be mounted on this directory. Ideally according to standard FHS cdrom should be mounted under '/media'.

b) /run:
The '/run' directory stores run-time variable data. Run-time vriable data means, data about the running system since last boot. For eg, running daemons.
Example: ls /run

c) /lost + found:
During system crash or in any other situation when Linux file system checker (fsck) recovers lost data, that data is stored in this directory. Data may or may not be in a good condition.
###################################################################################################################################################################################################################33
Topic9: Linux Filters:

- Linux Filter commands accept input data from stdin (standard input) and produce output on stdout (standard output). It transforms plain-text data into a meaningful way and can be used with pipes to perform higher operations.
- These filters are very small programs that are designed for a specific function which can be used as building blocks.
(In Linux, you can use the cat command along with various filters or pipes (|) to perform text processing tasks. Filters are small command-line programs that take input from a file or standard input (stdin), process it, and then send the output to standard output (stdout). By combining cat with filters and pipes, you can create powerful text processing pipelines. )
Linux Filter Commands: 
	cat
	cut
	grep
	comm
	sed
	tee
	tr
	uniq
	wc
	od
	sort
	gzip
---------	
a) Linux Cat Filters:
	When cat command is used inside pipes, it does nothing except moving stdin to stout.
	Syntax: cat <fileName> | cat or tac |  cat or tac |. . .  
	Example: cat weeks.txt | tac | cat | cat | tac 
-----------	
b) Linux cut Command:
Linux cut command is useful for selecting a specific column of a file. It is used to cut a specific sections by byte position, character, and field and writes them to standard output. It cuts a line and extracts the text data. It is necessary to pass an argument with it; otherwise, it will throw an error message.

To cut a specific section, it is necessary to specify the delimiter. A delimiter will decide how the sections are separated in a text file. Delimiters can be a space (' '), a hyphen (-), a slash (/), or anything else. After '-f' option, the column number is mentioned.

Syntax: cut OPTION... [FILE]... 
 
Options:
The following command line options are used by the cut command to make it more specific:
-b, --bytes=LIST: It is used to cut a specific section by bytes.
-c, --characters=LIST: It is used to select the specified characters.
-d, --delimiter=DELIM: It is used to cut a specific section by a delimiter.
-f, --fields=LIST: It is used to select the specific fields. It also prints any line that does not contain any delimiter character, unless the -s option is specified.
-n: It is used to ignore any option.
--complement: It is used to complement the set of selected bytes, characters or fields
-s, --only-delimited: It is used to not print lines that do not have delimiters.
--output-delimiter=STRING: This option is specified to use a STRING as an output delimiter; The default is to use "input delimiter".
-z, --zero-terminated: It is used if line delimiter is NUL, not newline.
--help: It is used to display the help manual.
--version: It is used to display the version information.

Examples of the cut command:
Let's see the following examples of the cut command:
		i) Cut by using Hyphen as delimiter
		ii) Cut by using Space as delimiter
		iii) Cut by byte position
		iv) Cut by character
		v) Cut by complement pattern
		
i) Using Hyphen (-) As Delimiter:
To cut by using the hyphen (-) as the delimiter, execute the below command:
	cut -d- -f(columnNumber) <fileName>    
Consider the following commands:
	cut -d- -f2 marks.txt    
	cut -d- -f1 marks.txt    
from the above commands, the output will be trimmed from hyphen (-). 

ii)Using Space As Delimiter:
If we want to use space as a delimiter, then we have to quote the space (' ') with the cut command. To cut the output by using space as delimiter, execute the command as follows:
	cut -d ' ' -f(columnNumber) <fileName>    
Consider the following commands:
	cut -d ' ' -f2 exm.txt  
	cut -d ' ' -f5 exm.txt  

iii) Cut by byte:
The '-b' option is used to cut a section of line by byte. To cut a file by its byte position, execute the command as follows:
	cut -b <byte number> <file name>  
Consider the below command:
	cut -b 2 exm.txt 
	
iv) Cut by Character:
The '-c' option is used to cut a specific section by character. However, these character arguments can be a number or a range of numbers, a list of comma-separated numbers, or any other character.
To cut by specified character, execute the command as follows:
	cut -c < characters> <file name>  
Consider the below commands:
	cut -c 1,6 exm.txt  
	cut -c 1-3 exm.txt  

v) Cut by Complement Pattern:
The '--complement' option is used to cut by the complement. This option is supported by the BSD version of the cut. To cut by the complement pattern, execute the command as follows:
	cut --complement < complement pattern> <file name>  
The compliment pattern can be a list of bytes, characters, or fields.
Consider the below command:
	cut --complement -c 1 exm.txt 
-----------	
c) Grep Command in Linux/Unix with Examples:
The 'grep' command stands for "global regular expression print". grep command filters the content of a file which makes our search easy.

Ref: https://www.javatpoint.com/linux-grep
-------
d) Linux comm:
- The 'comm' command compares two files or streams. By default, 'comm' will always display three columns. First column indicates non-matching items of first file, second column indicates non-matching items of second file, and third column indicates matching items of both the files. Both the files has to be in sorted order for 'comm' command to be executed.
Syntax: comm <file1> <file2>  
Example: comm file1.txt file2.txt
Output example is explained as below;
First column displays non-matching items of first file 'file1.txt' (Sehwag, Yuvi)
Second column displays non-matching items of second file 'file2.txt' (Zadeja)
Third column indicates matching items of both the files (Dhoni, Dravid, Sachin)

To Display Single Column:
- If you want to output a single column, you have to specify number of the columns which are not to be displayed.

Syntax:
comm -23 (To display first column)
comm -13 (To display second column)
comm -12 (To display third column)

Example:
comm -23 file1.txt file2.txt
comm -13 file1.txt file2.txt
comm -12 file1.txt file2.txt
----------
e) Sed Command in Linux/Unix with Examples:
- Linux 'sed' command stands for stream editor. It is used to edit streams (files) using regular expressions. But this editing is not permanent. It remains only in display, but in actual, file content remains the same.
- Primarily, it is used for text substitution; additionally, it can be used for other text manipulation operations like insert, delete, search, and more. The sed command allows us to edit files without opening them. Regular expression support makes it a more powerful text manipulation tool.

Ref: https://www.javatpoint.com/linux-sed
-------------
f) Linux tee Command:
- Linux tee command is quite similar to the 'cat' command, with only one difference. It puts stdin on stdout and also put them into a file. It is one of the most used commands with other commands through piping. It allows us to write whatever is provided from std input to std output. Optionally, it provides writing to one or more files. The command name tee comes from T splitter used in plumbing.

Syntax: tee <options> <file name>  
Options:
The following are some useful options that can be used with the tee command to make it more specific:
-a, --append: It is used to append the data to the given files, it does not overwrite data.
-i, --ignore-interrupts: It is used to ignore the interrupt signals.
-p: It is used to diagnose errors writing to non-pipes.
--output-error[=MODE]: It is used to set behavior on write error mode.
--help: It is used to display the help documentation.
--version: it is used to display the version information.

Examples of the tee Command:
Let's see the following examples of the tee command:
		How to use the tee command
		Write a file and append output
		Write the state of Data to a File
		Write to multiple files
		Write to a privileged file
		Ignoring Interrupts
		Hide the output
i) How to use the tee command:
The tee command is used to write a standard input to standard output and a file. It is used after a pipe. To write to standard output and a file, specify the tee command after a pipe and provide the file(s) name. Consider the below command:
	cat weeks.txt | tee newfile.txt  
The above command will write the input of the 'weeks.txt' to 'newfile.txt'.

ii) Write a file and append output:
The '-a' option is used with the tee command to append the output and write it to a file. Consider the below command:
	echo 'Saturday and Sunday are week offs' | tee -a newfile.txt  
The above command will append the specified input to the 'newfile.txt'.

iii) Write the State of Data to a File:
Writing the state of data is very useful for taking backup or creating a snap of the data for the debugging purpose. It can be easily done by using the tee command.

To write the state of data to a file, execute the below command:
	ls ~/ | tee pipe1.txt | grep ^b | tee pipe2.txt | sort -r  
The above command will write the data to the pipe1.txt. 

iv) Write to multiple files:
The tee command allows us to write to multiple files. To write to the multiple files, specify the names of the files after the tee command as follows:
	echo " add text" | tee file1.txt file2.txt file3.txt  
The above command will create all the specified files.

v) Write to a privileged file:
The tee command allows us to write to a file having sudo privilege. If we try to write a file owned by the root user will through the permission error. But, we can elevate the sudo permission by executing the tee command as follows:
	echo "some text" | sudo tee -a <file name>  

vi) Ignoring Interrupts:
The '-i' option is used to ignore the interrupts. This is useful if we want to stop and exit the command gracefully during the execution. It is used as follows:
	command | tee -i <filename>  

vii) Hide the output:
To restrict the tee command not to write to the standard output, redirect it to "/dev/null". Execute the command as follows:
	echo "Text" | tee newfile.txt >/dev/null 
-----------------
g) Linux tr:
The command 'tr' stands for 'translate'. It is used to translate, like from lowercase to uppercase and vice versa or new lines into spaces.
Syntax: command | tr <'old'> <'new'>
  
i) Change Case:
The 'tr' command can change case.
Syntax:	command | tr <'old'> <'new'>  
Example: cat exm.txt | tr 'prcu' 'PRCU'  

ii) Remove New Lines:
To write all the lines into a single line we have to translate all new lines into spaces.
Syntax: command | tr <'\n'> <' '>  
Example: cat exm.txt | tr '\n' ' '  

iii) tr Options
tr -s : The 'tr -s' command squeezes the occurence of multiple characters into one.
Syntax: command | tr -s <'letter'>   
Example:
cat jtp.txt | tr -s 'l'  
    cat spaces.txt | tr -s ' ' 
tr rot13: This command encrypts the text. It is case-sensitive.
Example:
cat exm.txt | tr 'a-z' 'nopqrstuvwxyzabcdefghijklm'  
    cat exm.txt | tr 'a-z' 'n-za-m'  
tr -d: The 'tr -d' command is used to delete characters.
Syntax: command | tr -d <letter>  
Example: cat exm.txt | tr -d o  
---------------
h) Linux uniq Command:
Linux uniq command is used to remove all the repeated lines from a file. Also, it can be used to display a count of any word, only repeated lines, ignore characters, and compare specific fields. It is one of the most frequently used commands in the Linux system. It is often used with the sort command because it compares adjacent characters. It discards all the identical lines and writes the output.

Syntax: uniq [OPTION]... [INPUT [OUTPUT]]  
Options:
Some useful command line options of the uniq command are as following:
-c, --count: it prefixes the lines by the number of occurrences.
-d, --repeated: it is used to print duplicate lines, one for each group. 	
-D: It is used to print all the duplicate lines.
--all-repeated[=METHOD]: It is quite similar to the '-D' option, the difference between both the options is that it allows separation of groups with an empty line.
-f, --skip-fields=N: It is used to avoid comparison of the first N fields.
--group[=METHOD]: It is used to display all items and separates the groups with an empty line.
-i, --ignore-case: It is used to ignore the differences while comparing.
-s, --skip-chars=N: It is used to avoid the comparison of the first N characters.
-u, --unique: it is used to print unique lines.
-z, --zero-terminated: It is used for the line delimiter is NUL and not newline mode.
-w, --check-chars=N: It is used to compare not more than N characters in lines.
--help: It is used to display help documentation.
--version: It is used to display the version information.

Examples of uniq Command
Let's see the following examples of the uniq command:
		Remove repeated lines
		count the number of occurrences of a word
		Display the repeated lines
		Display the unique lines
		Ignore characters in comparison
		Ignore fields in comparison

Remove repeated lines:
To remove repeated lines from a file, execute the basic uniq command as follows:
	sort dupli.txt | uniq  
The above command will remove the duplicate lines from the file 'dupli.txt.' 

Count the number of occurrences of a word:
We can count the number of occurrences of a word by using the uniq command. The '-c' option is used to count the word. Execute it as follows:
	sort dupli.txt | uniq -c  
The above command will count the words which come in 'dupli.txt'. 

Display the repeated lines:
The '-d' option is used to display only the repeated lines. It will only display the lines that will be more than once in a file and write the output to standard output. Consider the below command:
	sort dupli.txt | uniq -d  
The above command will display only the repeated lines.

Display the unique lines:
The '-u' option is used to display only the unique lines ( which are not repeated). It will only display the lines that occur only once and write the result to standard output. Consider the below command:
	sort dupli.txt | uniq -u  
The above command will display only the unique lines from the file 'dupli.txt'. 

Ignore characters in comparison:
The '-s' option is used to ignore the characters in comparison. It will ignore the specified number of characters and display the result to standard output. Consider the below command:
	sort dupli.txt | uniq -s 2  
The above command will ignore the first two characters in comparison from the file 'dupli.txt'.

Ignore fields in comparison:
The '-f' option is used to ignore the fields. Consider the below command:
	uniq -f 2 dupli2.txt  
The above command will not compare the first two fields from the file 'dupli2.txt'.
------------
i) Linux wc Command
Linux wc command helps in counting the lines, words, and characters in a file. It displays the number of lines, number of characters, and the number of words in a file. Mostly, it is used with pipes for counting operation.
wc is short for word count. 
Ref: https://www.javatpoint.com/linux-wc
-----------
j) Linux od:
The 'od' term stands for octal dump. It displays content of a file in different human-readable formats like hexadecimal, octal and ASCII characters.

Syntax:
od -b <fileName>      (display files in octal format)  
od -t x1 <fileName>       (display files in hexadecimal bytes format)  
od -c <fileName>      (display files in ASCII (backslashed) character format)  

Example:
od -b format.txt                            
od -t x1 format.txt  
od -c format.txt  
command "od -b format.txt" displays in octal format, command "od -t x1 format.txt" displays in hexadecimal format, command "od -c format.txt" displays in ASCII character where a new line will be marked with '\n'
---------------
k) Linux sort: Ref: https://www.javatpoint.com/linux-sort for example or better understanding with examples.
The 'sort' command sorts the file content in an alphabetical order.
Syntax: sort <fileName>  
Example: sort weeks.txt  
To Sort A Column:
If a file has more than one column, column number is used to sort a specific column.
Syntax: sort -k<columnNumber> <fileName>   
Example:
sort -k1 states.txt  
sort -k2 states.txt  
Numeric Sorting:
Numeric sorting is different from alphabetical sorting. For numeric sorting option 'n' is used along with the column number if required.
Syntax: sort -n -k<columnNumber> <fileName>   
Example: sort -n -k2 marks.txt
----------------
l) Linux gzip: 
- Gzip (GNU zip) is a compressing tool, which is used to truncate the file size. By default original file will be replaced by the compressed file ending with extension (.gz).
- To decompress a file you can use gunzip command and your original file will be back.
Syntax:
gzip <file1> <file2> <file3>. . .   
gunzip <file1> <file2> <file3>. . .   
Example: 
gzip file1.txt file2.txt  
gunzip file1.txt file2.txt  
the gzip command has compressed the files 'file1.txt' and 'file2.txt'. Compressed files are shown with the extension (.gz). While gunzip command has decompressed the same files and extension (.gz) is removed.

gzip options:
Compressing Multi Files Together:
- If you want to compress more than one file together, you can use 'cat' and gzip command with pipe command.

Syntax: cat <file1> <file2>. . | gzip > <newFile.gz>   
Example: cat file1.txt file2.txt | gzip > final.gz 
gzip -l:
The 'gzip -l' command tells about the compression ratio or how much the original file has compressed.
Syntax: gzip -l <file1> <file2>. .   
Example: gzip -l final.gz jtp.txt.gz   

Q) How To Compress A Directory? 
A) The gzip command will not be able to compress a directory because it can only compress a single file. To compress a directory you have to use 'tar' command.

Hyphen (-) is not mandatory in 'tar' command.
'c' is to create,
'v' is for verbose, to display output,
'f' to mention destination of your output file,
'z' for specifying compress with gzip.  
Syntax:
tar cf - <directory> | gzip > <directoryName>  
OR
tar cvfz office.tar.gz office  
Example:
tar cf - office | gzip > office.tar.gz  
###############################################################################################################################################################################33
Topic10: Basic Linux Unix Tools : 
Basic Unix tools are used to do basic work like find a file, locate a file, set the date and time, display calender, etc.
There are a number of basic Unix tools. Some of them are listed below.
		find
		locate
		date
		cal
		sleep
		time
		zcat / zmore
		bzip2 / bunzip2
		bzcat / bzmore
		df

a) Find Command in Linux/Unix with Examples:
> The find command helps us to find a particular file within a directory. It is used to find the list of files for the various conditions like permission, user ownership, modification, date/time, size, and more.
> In Unix-like and other operating systems, the find command is a command-line utility that finds files on the basis of a few user-specified formats and either prints all matched object's pathname or, if other actions are requested, implements that action on all matched objects.
> The find utility comes by default with most of the Linux distros, so we don't need to install any additional package. It is one of the most essential and used commands of the Linux system.
		find <location> <comparison-criteria> <search-term>  
> The two options determine how find should consider symbolic links. The default nature is never to pursue symbolic links. The flag, i.e., -L, will lead find to pursue symbolic links. The flag, i.e., -H, will just pursue symbolic links while continuing with the command line arguments. The flags are mentioned in the POSIX standard for the find command. A basic extension is a flag, i.e., -P, to explicitly disable the symlink following.

The following symbols are used to specify the directory:

(.) : For current directory name
(/) : For the root directory

Predicates:
Widely used primaries are:
-name pattern: It checks that the file name is the same as the given shell-glob pattern or not.
-type type: It checks that the file is a provided type.
-print: It always gives the true value. It prints the current file name and a newline to stdout.
-print0: It always gives the true value. It prints the current file name and a null character to stdout. Not needed by POSIX.
-exec program [argument ...];: It always gives the true value. It executes a program with the fixed given arguments and the current file path.
-exec program [argument ...] { } +: It always gives the true value. It executes a program with the fixed given arguments and as several paths as possible. For almost every implementation, other {} occurrences mean extra copies of the given name (aspect not needed by POSIX).
-ok program [argument ...];: It is the same as -exec, but will return false or true if the program gives 0.
Find defaults to implementing -print in case the conditions are true if the expression utilizes none of -ok, -exec, -print, or -print0.

Operators:
Operators enhance the find command expressions. They are mentioned in order of descending precedence:
( expr ): This operator can force precedence.
! expr: If expr returns false, it returns true.
expr1 expr2 (or expr1 -a expr2 : AND. expr2 isn't evaluated if expr1 is false.
expr1 -o expr2 : OR. expr2 isn't evaluated if expr1 is true.

Examples of the find Command:
Let's see the following examples of the find command:
		i) Find files by name
		ii)	Find files by type
		iii) Find newer files
		iv)	Find and delete a file
		v) Find a directory
		vi) Find files by modification time
		vii) Find files by permission
		viii) Find and replace files
		ix) Find text within multiple files

i) Find files by name:
We can search all the files ending with the extension '.txt.' To do so, execute the below command:
		find . -name "*.txt"    
The above command will list all the text files from the current working directory.
ii) Finding files by type:
The '-type' parameter is used to specify the file type.
Some of the file types are as follows:
	f: regular file
	d: directory
	l: symbolic links
	c: character devices
	b: block devices
Consider the below command: find . -type d -name "*.bak" 
iii) Find newer files:
The '-newer' parameter helps in searching the files which are newer than the mentioned file. Consider the below command: find . -newer msg.txt  
iv) Find and delete a file:
The '-delete' option is used to delete a specific file. We need to be very careful while using this command because there is no undo option if it is once executed. Consider the below command: find . -name Demo.txt -delete  
v) Find a directory:
The ' type -d' option is used to find a directory. Consider the below command: find . type -depth -name Newdirectory   
vi) Find files by modification time:
The '-mtime' option, followed by the number of days, is used to find the files by modification. The number of days can be positive or negative. The negative value will be used for less than like -1 is used for the last day, and similarly, +1 will find the file for the more than one day ago. Consider the below command:
		find ./Newdirectory -mtime -1   
vii) Find files by permission:
The '-perm' option is used to find files by permission. Execute the find command with the '-perm' option and pass the required value. Consider the below command:
		find ./<directory name> -perm 777  
viii) Find and replace files
To find and replace files, we have to combine find command with the sed command. To operate on files, use the '-exec' option with the find command. Consider the below command:
		find ./Newdirectory -type f -exec sed -i 's/find/replace/g' {} \;  
ix) Find text within multiple files:
We can make another combination of the find command with the grep command to find the text from the various files. Consider the below command:
		find ./Newdirectory -type f -name "*.txt" -exec grep 'demo'  {} \;  
		
Search every directory:
$ find / -name file1 -type f -print  
The above command finds all directories for a regular file whose title is file1 and prints it on the screen. Generally, it's not a good idea to search for files this way. It can take a good amount of time. So, it's best to mention the directory. A few operating systems may mount file systems (dynamic) that are not favorable to the find command. More complicated file names containing characters unique to the shell may require to be closed in single quotes.
------------
b) Linux locate Command:
> The locate command and find command is used to search a file by name. But, the difference between both commands is that locate command is a background process and searches the file in the database whereas, find command searches in the filesystem. The locate command is much faster than find command.
> If you are unable to find a file with locate command, then it means that your database is out of date, and you can update your database with the "updatedb" command.

Syntax: locate [OPTION]... PATTERN...  
Options:
Some useful command line options are as following:
-A, --all: It is used to display only entries that match all PATTERNs instead of requiring only one of them to match.
-b, --basename: It is used to match only the base name against the specified patterns.
-c, --count: It is used for writing the number matching entries instead of writing file names on standard output.
-d, --database DBPATH: It is used to replace the default database with DBPATH.
-e, --existing: It is used to display only entries that refer to existing files during the command is executed.
-L, --follow: If the '--existing' option is specified, It is used for checking whether files exist and follow trailing symbolic links. It will omit the broken symbolic links to the output. This is the default behavior. The opposite behavior can be specified using the "--nofollow" option.
-h, --help: it is used to display the help documentation that contains a summary of the available options.
-i, --ignore-case: It is used to ignore case sensitivity of the specified patterns.
-p, --ignore-spaces: It is used to ignore punctuation and spaces when matching patterns.
-t, --transliterate: It is used to ignore accents using iconv transliteration when matching patterns.
-l, --limit, -n LIMIT: If this option is specified, the command exit successfully after finding LIMIT entries.
-m, --mmap: It is used to ignore the compatibility with BSD, and GNU locate.
-0, --null: It is used to separate the entries on output using the ASCII NUL character instead of writing each entry on a separate line.
-S, --statistics: It is used to write statistics about each read database to standard output instead of searching for files.
-r, --regexp REGEXP: It is used for searching a basic regexp REGEXP.
--regex: It is used to describe all PATTERNs as extended regular expressions.
-V, --version: It is used to display the version and license information.
-w, --wholename: It is used for matching only the whole path name in specified patterns.

Examples of the locate Command:
Let's see the following examples of the locate command:
	How to use the locate command
	Limiting Search Queries
	Display The Number of Matching Entries
	Ignoring the case sensitivity
	Updating the mlocate Database
	Display Only Available Files in Our System
	Track status of the mlocate Database
	Separate Output Entries with a Different Separator

How to use the locate command:
Locate command is a useful utility for searching the files. It is pretty straight forward to use, just execute the command as follows:
		locate <file name> 
Limiting Search Queries:
We can limit the search results to avoid redundancy by using the "-n" option.
For example. To display the just 5 results from our queries, execute the command as follows:
		locate -n 5 "*.txt"  
Display The Number of Matching Entries:
To display the sum of matching files, execute the command with the '-c' option. Consider the below command:
		locate -c Demo*  
Ignoring the case sensitivity:
As we know, the Linux terminal is case sensitive. So, if we search a file in uppercase, it will only list the files in the upper case. To ignore the case sensitivity, execute the command with the '-i' option as follows:
		locate -i "demo.txt" 
Updating the mlocate Database:
The locate command depends upon the 'mlocate' database. So, if the locate command is not working properly, we need to update the database. To update the database, execute the 'updatedb' command as follows:
		sudo updatedb  
Display Only Available Files in Our System:
Sometimes, the locate command results deleted files. To avoid seeing the results for the deleted files, execute the command with the '-e' option. It will only display the files that are physically available in our system. Consider the below command:
		locate -i -e *demo.txt*  		
Track status of the mlocate Database:
To locate the database statistics, execute the command with the '-S' option as follows:
		locate -S
Separate Output Entries with a Different Separator:
The default output separator of the locate command is a newline. But we can change the default separator, For example, To use the ASCII NUL, execute the command using the '-0' option. Consider the below command:
		locate -i -0 "demo.txt"  
---------------
c) Linux date Command:
> Linux date command is used to display date, time, time zone, etc. It is also used to set the date and time of the Linux system. Generally, it is used to display the date in different formats and calculate dates over time.

Syntax:
date [OPTION]... [+FORMAT]  
date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]  

Options:
The following are some useful command line options of the date command:
-d, --date=STRING: It is used to display time described by STRING.
--debug: It is used to annotate the parsed date, and provide a warning about controversial usage to the stderr.
-f, --file=DATEFILE: It is similar to the '--date' option.
-I[FMT], --iso-8601[=FMT]: It is used to display the date/time in ISO 8601 format.
-R, --rfc-email: It is used to display the date and time in RFC 5322 format. For example, Mon, 14 Aug 2006 02:34:56 -0600.
--rfc-3339=FMT: It is used to display date/time in RFC 3339 format.
-r, --reference=FILE: It is used to display the previous modification time of the FILE.
-s, --set=STRING: It is used to set time described by STRING.
-u, --utc, --universal: It is used to display or set the UTC.
--help: It is used to display the help manual.
--version: It displays the version information.

Formatting options:
%a: It is used to display the abbreviated weekday name (e.g., Sun)
%A: It is used to display the full weekday name (e.g., Sunday)
%b: it is used to display the abbreviated month name (e.g., Jan)
%B: It is used to display the full month name (e.g., January)
%c: It is used to display the date and time (e.g., Thu Mar 3 23:05:25 2005)
%C: It is used to display the century; like %Y, except omit last two digits (e.g., 20)
%d: It is used to display the day of the month (e.g., 01)
%D: It is used to display date; same as %m/%d/%y
%e: It is used to display the day of the month, space padded; same as %_d
%F: It is used to display the full date; same as %Y-%m-%d
%g: It is used to display the last two digits of the year of ISO week number (see %G)
%G: It is used to display the year of ISO week number (see %V); normally useful only with %V.
%h: It is similar to the '%b' option.
%H: It is used for an hour (00..23)
%I: It is used for an hour (01..12)
%j: It is used for the day of the year (001..366)
%k: It is used for the hour, space padded ( 0..23); same as %_H
%l: It is used for the hour, space padded ( 1..12); same as %_I
%m: It is used for the month (01..12)
%M: It is used for the minute (00..59)
%n: It is used for a new line
%N: it is used for nanoseconds (000000000..999999999)
%p: It is used to pass the equivalent of either AM or PM; blank if not known
%P: It is similar to the '%p' option, But, it is passed in lower case.
%q: It is used to display the quarter of a year (1..4)
%r: It is used to display the 12-hour clock time (e.g., 11:11:04 PM)
%R: It is used to display the 24-hour clock time in an hour and minute; same as %H:%M
%s: it is used to display the seconds since 1970-01-01 00:00:00 UTC
%S: it is used to display the second (00..60)
%t: It is used for a tab option.
%T: it is used to display the time; same as %H:%M:%S
%u: It is used for the day of the week (1..7); 1 is Monday
%U: It is used for a week number of year, it counts Sunday as the first day of the week (00..53)
%V: It is used for the ISO week number, it counts Monday as the first day of the week (01..53)
%w: It is used for the day of the week (0..6); 0 is Sunday
%W: It is used for the week number of year, It counts Monday as the first day of the week (00..53)
%x: It is used for the date representation (e.g., 12/31/99)
%X: It is used for the time representation (e.g., 23:13:48)
%y: It is used for the last two digits of the year (00..99)
%Y: It is used for a year
%z: It is used for the +hh:mm numeric time zone (e.g., -0400)
%:z: It is used for the +hh:mm numeric time zone (e.g., -04:00)
%::z: It is used for the +hh:mm:ss numeric time zone (e.g., -04:00:00)
%:::z: It is used for the numeric time zone with ':' to necessary precision (e.g., -04, +05:30)
%Z: It is used for the alphabetic time zone abbreviation (e.g., EDT)

Examples of the date Command
Let' see the following examples of the date command:
	How to use the date Command
	Date formatting
	Date Strings
	Overriding the Timezone
	Date Command as Epoch Converter
	Display the last modification time of a file
	Set the system date and time
	
How to use the date Command:
> The date command is basic utility, and it can be used by executing without any argument. It will display the current date and time. Consider the below command:
		date
Date Formatting:
> We can display the date in the format of our choice. There are several options to display the date in a specific format. Different date formats can be seen from the above list of formatting options. Consider the below commands:
	date '%a %d-%m-%y'  
	date +'%b %d-%m-%y'  
	date +'%B %d-%m-%y'  
	date +'%A %d-%m-%y'  
	date +'%c %d-%m-%y'  
	date +'%C %d-%m-%y'  
From the above commands, the date will display in different formats.
Date Strings:
> We can specify the date in different date strings. The '-d' option is used to operate on a specific date. Consider the below command:
		date -d "2020-06-06 12:10:53"  
From the above command, we have a specified date in a different format. 
We can also use the custom formatting as follows:
		date -d '06 jun 2020' +'%A, %d %B %Y'  
Also, we can pass the strings like "yesterday", "monday", "last monday" "next monday", "next month", "next year," and many more.
Consider the below commands:
	date -d now  
	date -d yesterday  
	date -d tomorrow  
	date -d "next monday"  
	date -d "last monday"
Overriding the Timezone:
> By default, the date command displays the time according to the current time zone. But, we can change it by setting the environment variable 'TZ.' The default value of the 'TZ' variable is stored in the file "/etc/localtime". After changing the value of the environment variable, we can display the time from different timezones. Consider the below commands:
	TZ='Australia/Melbourne' date  
	TZ=+5:30 date  
The above commands will display the time according to given timezones.
Date Command as Epoch Converter:
> The date command can also be used to display the Epoch time. The Epoch time (Unix time or Unix timestamp or POSIX time) is the time (in seconds) that have been elapsed since January 1, 1970.
To display the time from the epoch to the current date, execute the command with the '%s' option as follows:
	date +%s  
The above command will display the elapsed time from the epoch time.
To convert the time as the current date, prefix the seconds with '@'. Consider the below command:
	date -d @122222222  
The above command will convert the time (in seconds) to the human-readable format.
Display the last modification time of a file:
> The '-r' option is used to display the last modification time of the file. For example, to display the last modification time of the file 'Demo1.txt' execute the command as follows:
	date -r Demo1.txt  
The above command will display the time when the given file is modified.
Set the system date and time:
> We can set the time and date of the system by using the date command. However, it is not recommended to set the date and time of the system by the date command. Because The Linux system clock is synchronized using the sytemd-timesyncd or ntp services.
> To set the time by the date command, use the "--set= time" option. For example, if we want to set the date and time as "08:15 pm, June 06, 2020", execute the command as follows:
	date --set="20200606 22:15"  
The above command will set the time as specified. 
-----------
d) Linux cal:
The 'cal' term stands for calender. It displays current month's calender with current day highlighted.
Syntax: cal  

Displaying Past Or Future Month:
You can also display past or future year's month with cal command.
Syntax: cal <month> <year>  
---------------
e) Linux sleep Command:
> Linux sleep command lets the terminal wait by the specified amount of time. By default, it takes time in seconds. But, we can set the delay time in minutes (m), hours (h), and days (d). It helps in pausing the execution of any particular command for a fixed amount of time.

Syntax:
sleep NUMBER[SUFFIX]...  
sleep OPTION  
Suffix may be 's,' 'm,' 'h,' 'd' for seconds, minutes, hours, or days respectively. And, the number is an integer; also, the number can be a floating-point number. If we specify two arguments, then it will pause the terminal for the sum of those number's amount of time.

Options:
The sleep command supports only two command line options, which are as follows:
--help: It is used to display the help manual.
--version: It is used to display the version information.

Examples of the sleep command:
Let's see the following examples of the sleep command:
	Default sleep command
	Specify time in minutes
	Specify time in hours
	Specify time in days
	Exit from the sleep mode
	Set an alarm using sleep
	sleep with loop
	Execute two commands after a time interval
	
Default sleep command:
- The default sleep command will take time in seconds. Consider the below command:
		sleep 5  
The above command will pause the terminal for 5 seconds.
Specify time in minutes:
- To specify the time in minute, use the 'm' argument with time. It will pause the terminal for the specified time in minutes. Consider below command:
		sleep 0.05m  
The above command will pause the terminal for the given time. 
Specify time in hours:
- To specify the time in hour, use the 'h' argument with time. It will pause the terminal for the given amount of time. Consider below command:
	sleep 0.002h  
The above command will pause the terminal for the given time.
Specify time in days:
- To specify the time in days, use the 'd' argument with the time. It will pause the terminal for the given amount of time. However, it is useless to pause the terminal for days. Consider the below command:
		sleep 0.0005d  
The above command will pause the terminal for the given days.
Exit from the sleep mode:
- To exit from the sleep mode, press "CTRL+C" keys. This key combination does exist, even if the terminal is on sleep mode. It will instantly take you out from the sleep mode.
Set an alarm using sleep:
- If we want to set a reminder for the specified amount of time. We can do this by using the sleep command as well. To do so, execute the sleep command with the specified amount of time and an audio or video file. Consider the below command:
		sleep 5; rhythmbox sound.mp3  
the above command will play the specified audio file with Rhythmbox immediately after the execution of the command.
sleep with loop: 
- The sleep command can be used for multiple purposes. Also, it can be used with loops. For example, the initial value of n =1, and we want to perform sleep operation for every incremented value of n. To do so, execute the below script:
n=1  
while [ $n -lt 7 ]  
do  
echo "Current value of n is = $n"  
sleep 2s  
echo " "  
((n=$n+1))  
done  
The above script will execute the sleep command in the loop.
Execute two commands after a time interval:
Suppose, we want to execute two commands after a fixed time interval. We can do this by executing the sleep command as follows:
		pwd && sleep 2 && ls  
The above command will display the current working directory, and after two seconds, it will display the directory list. 
--------------
f) Linux time Command:
- Linux time command displays how long it takes to execute a command. It helps in checking the performance of the scripts and commands.
- The time command can be run with various arguments (commands). When it is successfully executed, it displays the information about used resources and time by the given command.
Syntax: The basic syntax of the time command is as follows:
		time [option] [command]  
Options: Some useful options supported by the time command are as following:
-o FILE, --output=FILE: It is used to specify the resource and uses statistics to a FILE instead of the standard error stream. By default, it deleted the previous file content and overwrote the file.
-a, --append: It is used to attach resources so that information can be used instead of overwriting it in the output file. This option is useful with the '-o' option.
-f FORMAT, --format FORMAT: It is used to use the FORMAT as the format string that controls the output of time.
--help: It is used to display the help documentation that contains the summary of the supported options and usages.
-p, --portability: It is used to use the following options to conform to POSIX standard 1003.2:
		real %e
		user %U
		sys %S
-v, --verbose: It is used to display the output verbosely.
--quiet: It is used for not reporting the status of the program even if it is different from zero.
-V, --version: It is used to display the version information of the installed time command.

Examples of the time command:
Let's see the following examples of the time command:
	How to use the time command
	Write the output to a file
	Display the detailed output
	Customize the output
	Display the version information
	Getting Help
How to use the time command:
- The default use of the time command is pretty straightforward: execute the time command with an input command. It will display the time taken by the given command. Consider the below command:
		time ls  
The above command will display the time taken by the ls command.
Write the output to a file:
- The '-o' option is used to write the output to a file instead of displaying it on the terminal. Consider the below command:
		/usr/bin/time -o time.txt pwd  
The above command will store the output to the given file. 
we can see that the pwd command's output is stored in the file 'time.txt.' by using above command.
Display the detailed output:
- The '-v' option is used to display the detailed output. Consider the below command:
		/usr/bin/time -v time.txt pwd  
The above command will display the output verbosely.the detailed description is displayed using the '-v' option.
Customize the output:
- We can customize the output of the time command by using the 'format' option. It facilitates a set of resource specifiers to fetch the information. For example, execute the below command:
		/usr/bin/time -f "\t%C [Command details],\t%K [Total memory usage],\t%k [Number of signals process received]" pwd  
The above command will display the specified information in the given format. 
Display the version information:
- To display the version information of the time command, execute the command as follows:
		/usr/bin/time -V  
The above command will display the installed version of the time command.
Getting Help:
To take the help from the terminal, execute the command with the '--help' option as follows:
		/usr/bin/time -help  
The above command will display a list of supported options. 
we can also read the manual of the time command by executing the below command:
		man time  
It will display the manual page of the time command. 
Scroll the terminal to read more about the command and press the 'q' key to exit from this manual.
--------------
g) Linux zcat:
Compressed files or zipped files can be viewed with the help of 'zcat' command.
Syntax: zcat <fileName>  
Example: zcat acb 
Note: The command zmore and zless works same for zipped files as more and less command works for unzipped files. 
--------------
h) Linux bzip2:
- The command bzip2 is also used to compress a file like gzip command but takes a little more time but compresses better. Its extension will be (.bz2).
Syntax: bzip2 <fileName>  
Example: bzip2 acb  

bunzip2:
- The command bunzip2 decompress a file like gunzip command.
Syntax: bunzip2 <fileName>  
Example: bunzip2 acb.bz2  
-------------------------
i) Linux bzcat:
The command bzcat will display the files compressed with bzip command.
Syntax: bzcat <fileName>  
Example: bzcat acb.bz2
------------------
j) df Command in Linux/Unix with Examples:
- Linux df command is used to display the disk space used in the file system. The 'df' stands for "disk filesystem." It defines the number of blocks used, the number of blocks available, and the directory where the file system is mounted.
Syntax: df [OPTION]... [FILE]...  

Options:
-a, --all: It is used to include pseudo, duplicate, remote file systems.
-B, --block-size=SIZE: It is used to scale sizes by SIZE before printing them, for example, the '-BM' option prints sizes in units of 1,048,576 bytes.
-h, --human-readable: It is used to display sizes in powers of 1024 (e.g., 1023M).
-H, --si: It is used to show sizes in powers of 1000 (e.g., 1.1G)
-i, --inodes: It is used to list inode information instead of block usage
-l, --local: It is used to limit the listing to local file systems.
--no-sync: It is used for not invoking sync before getting usage info (default).
--output[=FIELD_LIST]: This option used if we want to use the output format defined by FIELD_LIST or print all fields if FIELD_LIST is omitted.
-P, --portability: It is used to use the POSIX output format.
--total: It is used to exclude all entries insignificant to available space, and produce a total.
-t, --type=TYPE: It is used to limit the listing to file systems of type TYPE.
-T, --print-type: It is used to display the file system type.
-x, --exclude-type=TYPE: It is used to limit the listing to file systems, not of type TYPE.
--help: It is used to display the help manual having brief information about the supported options.
--version: It is used to display the version information of the df command.

Examples of the df command:
Let's see the following examples of the df command:
		Display the disk space usage
		Display the disk space usage in a human-readable form
		Display the file system type
		Display specific file system types
		Exclude the particular file system types
		Display available space and mount point for a folder
Display the Disk Space Usage:
> To display the disk space usage, execute the df command without any argument. It will show the disk space usage in a tabular form. The df command is useful for discovering the available free space on a system or file system. Execute the below command:
		df  
Display the disk space usage in a human-readable form:
> The '-h' option is used to display the disk space in a human-readable form. It will display the size in powers of 1024 and will append G for GBs, M for MBs, and B for Bytes. Execute the below command:
		df -h  
Display the file system type:
> The '-T' option is used to display the file system type. It will add a new column having the file system type to output. Execute the below command:
		df -T  
Display specific file system types:
> The '-t' option is used with the file system type to display the specific file system. It will only display a given file system. We can specify more than one file system with it. Consider the below command:
		df -t ext4  
Exclude the specific file system types:
>  The '-x' option is used with the specific file system type to exclude it from the output. It will display all other file system types except the given types. Consider the below command:
		df -x squashfs  
Display available space and mount point for a folder:
> To display the available space, file system type, and mount point of a folder, pass the folder name with the df command. Consider the below command:
		df Newdirectory  
###################################################################################################################################################################################################################################################
Topic11: Linux File Security
Linux File Ownership:
Every Linux system have three types of owner:

User: A user is the one who created the file. By default, whosoever, creates the file becomes the owner of the file. A user can create, delete, or modify the file.
Group: A group can contain multiple users. All the users belonging to a group have same access permission for a file.
Other: Any one who has access to the file other than user and group comes in the category of other. Other has neither created the file nor is a group member.
* Users and groups can be locally managed in /etc/psswd or /etc/group.
Syntax: ls -lh 

Listing User Accounts:
- To know the local users account, following command can be used. It list out all the local users from the system.
Syntax: cut -d: -f1 /etc/passwd | column   

Linux chgrp: change group:
The chgrp command can be abbreviated as change group. You can change the group owner of the file using chgrp command.
Syntax: chgrp <newGroup> <fileName>  
Example: chgrp php file  
Note: Only root user have the permissison to change the owner or group of the files in the system.

Linux chown: change owner:
Command chown is used to change the owner of the file.
Syntax: chown <newOwner> <fileName>  
Example: chown jtp list  
Command chown can also be used to change both user owner and group.
Syntax: chown <newOwner:newGroup> <fileName>  
Example: chown jtp:php msg.txt  

List of Special Files:
When we type ls -l command, ten characters are displayed before user owner and group. First character tells us about the type of the file.
Following are the file types:
----------------------------------------------
First Character		|		File Type
----------------------------------------------
-					|	Normal file
d					|	Directory
l					|	Symbolic link
p					|	Named pipe
b					|	Blocked device
c					|	Character device
s					|	Socket
----------------------------------------------
first letter (-) denotes the normal file and d denotes the directory.
-------------
Linux chgrp Command | Linux Change Group:
- Linux chgrp command is used to change the group ownership of a file or directory. In the Linux file system, each file is related to corresponding owner and group, and has read, write, and execute permission.

Syntax:
chgrp [OPTION]... GROUP FILE...  
chgrp [OPTION]... --reference=RFILE FILE...  
Options:
The chgrp command supports the following command-line options:
-c, --changes: It is like 'verbose' option but, it is reported only when a change is made.
-f, --silent, --quiet: It is used to suppress most error messages.
-v, --verbose: It is used to display a diagnostic for every file processed.
--dereference: It is used to affect each symbolic link's significance, rather than the symbolic link itself.
-h, --no-dereference: It is used to alter the symbolic links instead of any referenced file
--no-preserve-root: It is used for not treating the '/' especially.
--preserve-root: It is used when the default command is failed to operate recursively on '/.'
--reference=RFILE: It is used to use RFILE's group rather than a specific group.
-R, --recursive: It is used to operate on files and directories recursively. The option specifies the traversing of the '-R' option.
-H: It is used to traverse a symbolic link to a directory.
-L: It is used to traverse every symbolic link to a directory encountered.
-P: If this option is specified, it will not traverse any symbolic links (default)
--help: It is used to display the help manual having the brief information of supported command-line options.
--version: It is used to display version information.

Examples of the chgrp Command:
Let's see the following examples of the chgrp command:
		Change the group ownership of a file
		Change the group ownership of a folder
		Recursively change the group ownership of a folder and its contents
		Change group by using the group name of a reference file
Change the Group Ownership of a File:
We can change the group of any specific file. To change the group ownership of a file, execute the command as follows:
		sudo chgrp javatpoint Demo1.txt  
Change the group ownership of a folder:
To change the group ownership of a folder, execute the 'chgrp' command with the folder name as follows:
		sudo chgrp javatpoint Newdirectory 
Recursively change the group ownership of a folder and its content:
We can change the group ownership of a file or folder recursively by applying some set of rules. To recursively change the group ownership of a folder and its content, execute the command as follows:
		sudo chgrp -R javatpoint Newdirectory  
Change group by using the group name of a reference file:
We can change the group of a file by using the group name of a reference file. To change the group of another file using the reference of any other file or directory, execute the command as follows:
		sudo chgrp -R --reference=ref.txt Newdirectory  
---------------------------
File Permissions:
All the three owners (user owner, group, others) in the Linux system have three types of permissions defined. Nine characters denotes the three types of permissions.

Read (r) : The read permission allows you to open and read the content of a file. But you can't do any editing or modification in the file.
Write (w) : The write permission allows you to edit, remove or rename a file. For instance, if a file is present in a directory, and write permission is set on the file but not on the directory, then you can edit the content of the file but can't remove, or rename it.
Execute (x): In Unix type system, you can't run or execute a program unless execute permission is set.But in Windows, there is no such permission available.

Permissions are listed below:
---------------------------------------------------------------------------------------------------------
permission  |		on a file			|		on a directory
---------------------------------------------------------------------------------------------------------
r (read)	|  read file content (cat)	|	read directory content (ls)
w (write)	|  change file content (vi)	|	create file in directory (touch)
x (execute)	|  execute the file			|	enter the directory (cd)
---------------------------------------------------------------------------------------------------------

Permission Set:
 there are ten characters (-rw-rw-r--) before the user owner. We'll describe these ten characters here.

File permissions for (-rw-rw-r--)
---------------------------------------------------------------------------------------------------------
position	|		characters	|		ownership
---------------------------------------------------------------------------------------------------------
1			|			-		|	denotes file type
2-4			|			rw-		|	permission for user
5-7			|			rw-		|	permission for group
8-10		|			r--		|	permission for other
---------------------------------------------------------------------------------------------------------
* When you are the User owner, then the user owner permission applies to you. Other permissions are not relevant to you.

* When you are the Group then the group permission applies to you. Other permissions are not relevant to you.

* When you are the Other, then the other permission applies to you. User and group permissions are not relevant to you.

Setting Permissions With chmod:
You can change the permissions with chmod command accordingly to your need. Below are some examples to change the permissions for different groups.

To add permissions to a group.
Syntax: chmod <groupName>+<permissionName> <fileName>  
Example: chmod u+x file 

To remove permissions from a group
Syntax:
chmod <groupName>-<permissionName> <fileName>  
Example:
chmod g-x file  
chmod u-w file 

To add permission to all the groups together
Syntax: chmod a+<permissionName> <fileName>  
Example: chmod a+w file  
Note: Similarly, you can also remove the permission for all the groups.

To add permission to all the groups without typing a
Syntax: chmod +<permissionName> <fileName>  
Example: chmod +w file  

To set explicit permission
Syntax: chmod <groupName>=<permissions> <fileName>  
Example: chmod o=rw file  

To set explicit permissions for different groups
Syntax: chmod <groupName>=<permissions> <fileName>  
Example: chmod u=rwx,g=rw,o=r file  

Setting Octal Permissions:
Octal permissions can also be set for the groups.
For example, to set r octal will be 4, to set w octal will be 2, to set x octal will be 1.

Octal Table:
--------------------------------------------------
binary	|	octal	|	permissions
--------------------------------------------------
000		|		0	|		---
001		|		1	|		--x
010		|		2	|		-w-
011		|		3	|		-wx
100		|		4	|		r--
101		|		5	|		r-x
110		|		6	|		rw-
111		|		7	|		rwx
--------------------------------------------------
From this we can conclude that,
777 = rwxrwxrwx  
765 = rwxrw-r-x  
654 = rw-r-xr--  
and so on.

umask:
- While creating a file or directory, by default a set of permissions are applied. These default permissions are viewed by umask command.
- For safety reasons all Unix systems doesn't provide execution permission to newly created files.
- Adding execution permission is upto you.

mkdir -m:
The 'mkdir -m' command can be used to set the mode.
Syntax: mkdir -m <mode> <fileName>  
Example:
mkdir -m 777 new1  
mkdir -m 000 new2  

cp -p:
The 'cp -p' command preserves the permissions and time stamps from source files.
Syntax: cp -p <sourceFile> <destinationFile>  
Example: cp -p list dupli.txt  
-----------------------
Chmod Command in Linux/Unix with Examples:
- Linux chmod command is used to change the access permissions of files and directories. It stands for change mode. It can not change the permission of symbolic links. Even, it ignores the symbolic links come across recursive directory traversal.
- In the Linux file system, each file is associated with a particular owner and have permission access for different users. The user classes may be:
		owner
		group member
		Others (Everybody else)
The file permissions in Linux are the following three types:
			read (r)
			write (w)
			execute (x)
The basic syntax of chmod command is as follows:
Syntax: chmod <options> <permissions> <file name>  
Generally implemented options are:
-R: It stands for recursive, i.e., add objects to subdirectories.
-V: It stands for verbose, display objects modified (unmodified objects are not displayed).
> The target object is influenced if a symbolic link is mentioned. File modes related to symbolic links themselves directly are not used typically.

The primary component of the chmod permission:
For instance, rwxr-x---

All groups of three characters specify permissions for all classes:
rwx: The leftmost three characters specify permissions for the file owner (i.e., the User class).
r-x: The three middle characters specify permissions for the group owning the file (i.e., the Group class).
---: The three rightmost characters specify permissions for the Other class. Users who aren't the file owner and group members can't access the file.

Options:
The chmod command supports the following command-line options:
-c, --changes: It is similar to the verbose option, but the difference is that it is reported if a change has been made.
-f, --silent, --quiet: It is used to suppress the error messages.
-v, --verbose: It is used to display a diagnostic for every processed file.
--no-preserve-root: It is used for not treating the backslash symbol ('/'), especially (the default).
--preserve-root: If this option is used, it will fail to operate recursively on backslash ('/').
--reference=RFILE: It is used to specify the RFILE's mode alternatively MODE values.
-R, --recursive: It is used to change files and directories recursively.
--help: It is used to display the help manual having a brief description of usage and support options.
--version: It is used to display the version information.

File Permission Syntax:
> If you are a new user, you may get confused with the different types of letters used to set the file permission. So, Before proceeding further with the chmod command, let's understand the file permission syntax.
> To set the permission of a file or directory, we have to specify the following things:
Who: Who we are. (user)
What: What change are we going to made ( Such as adding or removing the permission)?
Which: Which of the permissions?
> The permission statement is represented in indicators such as u+x, u-x. Where 'u' stands for 'user,' '+' stands for add, '-' stands for remove, 'x' stands for executable (which).

The user value can be:
u: the owner of the file
g: group member
o: others
a: all
The permission types can be r, w, and x.

Setting and Updating the Permissions:
To set the permission of a file, execute a permission statement with the chmod command. For example, we want to set the read and write permission for all users and groups of file 'Demo.txt.' We have to pass the "u=rw,go=rw Demo.txt" permission statement with chmod command. To display the file permission, execute the below command:
		ls -l Demo.txt  
To change the permission, execute the below command:
		chmod u=rw,go=rw Demo.txt  
		
Setting Permissions for Multiple Files:
We can set permission for multiple files at once by using the chmod command. To change the file permission of multiple files, specify the file pattern with the chmod command. For example, if we want to set read and write permission for all text files, specify the *. txt pattern with chmod command.
To view the permission of all text file from the current working directory, execute the below command:
		ls -l *.txt  
It will list all the text files with their permission mode.
To set the read and write permission for other users, execute the below command:
		chmod o+w *.txt  

Numerical Shorthand:
We can use the numeric values instead of letters to specify the permissions. A three-digit value is used to specify the permission. The leftmost digit represents the owner (u), and the middle digit represents the group members (g). The rightmost digit represents the others (o).

The following table represents the digits and their permissions:
------------------------------------------------------
Digits	|		Permissions
------------------------------------------------------
000		|	No permission
001		|	Execute permission
010		|	Write permission
011		|	Write and execute permissions
100		|	Read permission
101		|	Read and execute permissions
110		|	Read and write permissions
111		|	Read, write, and execute permissions
-----------------------------------------------------

Symbolic modes:
Also, the chmod command accepts the finer-grained symbolic notation, which permits changing specific modes. The symbolic mode consists of three elements, which are merged to form a single text string:
		$ chmod [references] [operator] [modes] file...  
The chmod program applies an operator to define how the file modes should be arranged. The below operators are approved:
------------------------------------------------------------------------------------------------------------------------------
Operator		|		Description
-------------------------------------------------------------------------------------------------------------------------------
+				|	It adds the described to the described classes.
-				|	It removes the described mode from the described classes.
=				|	It represents that the modes described are to be created the same modes for the described classes.
---------------------------------------------------------------------------------------------------------------------------------
The modes represent which permissions will to be removed or granted from the described classes. There are mainly three common modes that are related to the common permissions:
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Name				|	Mode	|			Description
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

read				|	r		|	It reads a file or lists the contents of a directory.
write				|	w		|	It writes to a directory or file.
execute				|	x		|	It recurses a directory tree or executes a file.
special execute		|	X		|	It is not permission but instead can be used rather than x. It uses the execute permissions for directories despite their current permissions and uses the execute permissions for a file that has at least an execute permissions bit set. It is helpful if used with the "+" operator and without setting the execute permission which would happen if we just used chmod -R a+rx ., whereas we can implement chmod -R a+rx . with x rather.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Multiple modifications can be described by isolating multiple symbolic modes along with commas. The chmod command will inspect the umask if a user isn't specified.

Special modes:
Also, the chmod command can change the special modes and extra permissions of a directory or file. The symbolic modes apply 's' to indicate the setgid and setuid modes and 't' to indicate the sticky mode. A mode is only used for the correct classes, despite whether other classes are mentioned or not.
Almost all operating systems numerically support the special mode specification, specifically in octal, but a few don't. Only the symbolic modes can be applied to these systems.

Some examples of the command line:
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Command														Description
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
chmod a+r publicComments.txt			|	It will add the read permission for every class (i.e., Group, Owner, and Others).
chmod a-x publicComments.txt			|	It will remove the execute permission for every class.
chmod a+rx viewer.sh					|	It will add the execute and read permissions for every class.
chmod u=rw, g=r, o=internalPlan.txt		|	It will set the write and read permissions for the user, ser read for Group, and reject access for Others.
chmod -R u+w, go-w docs					|	It will include the write permission into the directory docs and each of its content for the owner and deletes the write permission for others and group.
chmod ug=rw groupAgreements.txt			|	It will set the write and read permissions for Group and user.
chmod 664 global.txt					|	It will set the write and read permissions for Group and user and gives the read permission to Others.
chmod 744 Show_myCV.sh					|	It will set the execute, write, and read permissions for the user and gives the read permission to Group and Others.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------
Chown Command in Linux/Unix with Examples:
> Linux chown command is used to change a file's ownership, directory, or symbolic link for a user or group. The chown stands for change owner. In Linux, each file is associated with a corresponding owner or group.
> The Linux system may have multiple users. Every user has a unique name and user ID. If only a user is available in the system, the user will be the owner of each file.
> The Linux system may have multiple users. Every user has a unique name and user ID. If only a user is available in the system, the user will be the owner of each file.
> Users can be listed in different groups. The group allows us to set permission on the group level instead of setting permission on an individual level.
> The file's ownership in the system may be only altered or edited by a super-user. The users can't give away a file's ownership even if the user owns it. Only a group member can modify the group ID of a file to that group.
> In the operating system, different users have permission and ownership to guarantee that the files are protected and put limitations on who can change the file contents. There are distinct users who utilize the system in Linux:
	* A group can contain zero or multiple users. A user can be related to a "default group". Also, it can be a part of other groups in the system.
	* All users have a few properties related to them, like a home directory and user ID. We can insert users into any group for making the process of handling users easier.
> However, the -P, -L, and -H options are exclusive manually; describing more than one isn't taken as an error. The last specified flag determines the nature of the command will show. The chown command modifies the directory or file ownership indicated by the link and not the link ownership itself when we haven't mentioned the -h flag and a symbolic link is known.
> The chown command contains the opposite effects and modifies the link ownership itself and not that of the directory or file pointed by the link if we mention the -h flag. This command descends the described directories recursively if we describe both -R and -h flags.

Permissions and Ownership: To secure and protect directories and files in Linux, we can use permissions for controlling what a user can implement with a directory or file. Linux utilizes three different types of permissions, which are mentioned below:

Read: It permits the user for reading files and enables the user for reading directories or subdirectories saved inside it.
Write: It permits the user to delete and modify a file. It also permits a user to change its contents (delete, create, and rename files inside it) for directories. Changes make an impact on them until the execute permission isn't provided to the directory.
Execute: It permits it to get run on a file. For instance, if we have any file called exe.sh until we don't provide with it the execute permission, it will not run.

File Permission Types:
User: These file permissions impact the file's owner.
Group: These file permissions impact the group, which is the owner of the file. The user permission will be used if the user owner is inside this group rather than the group permissions.
Other: These file permissions impact every other user in the system.
Below is the general syntax of the chown command:
Syntax: chown [OPTION]... [OWNER][:[GROUP]] FILE...
  
Options:
Following are the command-line options of the chown command:
-c, --changes: It is used to display the detailed output like verbose, but it is reported when only a change is made.
-f, --silent, --quiet: It is used to suppress the error messages.
-v, --verbose: It is used to display a diagnostic for every processed file.
--dereference: It is used to affect the referent of each symbolic link.
-h, --no-dereference: It is used to affect the symbolic links instead of any referenced file.
--from=CURRENT_OWNER:CURRENT_GROUP: It is used to change the specific owner and group.
--no-preserve-root: It is used for not treating the backslash ('/') especially.
--preserve-root: If the chown is failed to operate recursively on backslash ('/').
--reference=RFILE: It is used to specify the RFILE's owner and group rather than their values.
-R, --recursive: It is used to perform operations on files and directories recursively.
--help: It is used to display the help manual having a brief description of the usage and options.
--version: It is used to display the version information.

Options :
-H: The command shall modify the user ID (also group ID if mentioned) of the directory preferred by the symbolic link and every file inside the file hierarchy under it if the -R flag is mentioned and a symbolic link referring to a type directory file is mentioned on the command line.
-L: The command shall modify the user ID (also group ID if mentioned) of the directory preferred by the symbolic link and every file inside the file hierarchy under it if the -R flag is mentioned. A symbolic link referring to a type directory file is mentioned on the command line or known during a file hierarchy traversal.
-P: The command shall modify the owner ID (also group ID if mentioned) of the symbolic link when the system provides its support for this operation if the -R flag is mentioned and a symbolic link is mentioned on the command line or known during a file hierarchy traversal. The chown command will not pursue the symbolic link of other parts of a file hierarchy.
-R: If a symbolic link is known and the link represents a directory, the directory's ownership is modified, but the directory is not traversed further. Also, if the -P, -L, -H, and -h options are not specified when the link represents a directory, and the symbolic link is known, that directory's group ownership is modified, but the directory is not further traversed.

Display the UID, GID, and Groups:
To display all the groups, execute the groups command as follows:
		groups  
The above command will list all the existing groups from your Linux system. Consider the below output:

To list the UID and GID, execute the id command as follows:
		id  
The above command will list all the UID and GID of their corresponding users and groups.

Display the User and Group Ownership of a File
To display the user and group owner of a file, execute the "ls -l" command with a specific file name. Consider the below command:
		ls -l Demo.txt  
The above command will display the user and group ownership of the 'Demo.txt.' 

Change the owner of a File (Using user name)
To change the owner of a file, pass the user name (new owner) with the chown command as follows:
		sudo chown <username> <File name>  
Consider the below command:
		sudo chown jtp Demo.txt  
The above command will set the jtp as the owner of the file 'Demo.txt'. 

Change the Owner of a File (Using UID)
We can change the owner of a file or directory using the UID of a user. To change the ownership by using the UID, pass the UID with chown command as follows:
		sudo chown 1000 Demo.txt  
The above command will change the ownership of the 'Demo.txt'.

Change the Group of a File:
To change the group of a file, specify group name or GID with the chown command. It represents similar behavior as chgrp command. Execute the chown command specifying the group name separated by a colon as follows:
		sudo chown :groupname Demo.txt   
or
		sudo chown :GID Demo.txt  
Consider the below command:
		sudo chown :adm Demo.txt  
The above command will change the group of 'Demo.txt.' 

Change the User and Group Name
We can change the user and group names together. To change the user and group name at once, execute the chown command as follows:
		sudo chown <User name/UID>:<Group name/GID> <File name>  
Consider the below command:
		sudo chown jtp:adm Demo.txt  
The above command will change the specified user name and group name together. 
---------------------------
Advanced File Permission:
Sticky Bit on Directory:
- Files can be protected in a directory from getting removed by other users who do not own it by preventing it with sticky bit. It is displayed at the same location as the x permission for others.
- It is represented by a t (x is also there) or a T (no x is there).
Example: chmod +t new1
Generally, sticky bit is found on /tmp directory.

setgid Bit on Directory:
- To make sure all the files in the directories are owned by the group owner of directory, setgid can be used. It is displayed on the same location as x permission for group. It is represented by a s (x is also there) or a S (no x is there).

setgid and setuid on Regular Files:
- With the help of these two permissions, an executable file is accessed with the permissions of the file owner instead of the executing owner. It means that if a program has root user and setuid permission is set on it, then a user will run that program as root. This can be dangerous as well as good for the security.
- When a user run passwd command, it executes with the root credentials.
---------------
*****Linux File Links :
- A Linux filesystem has many hard links and symbolic links. A link is a connectivity between the filename and the actual data byte in the disk space. More than one filename can link to the same data.

There are two types of links in Linux OS:
		Hard Links
		Soft Links
1) Hard Links:
- They are the low-level links. It links more than one filename with the same Inode and it represents the physical location of a file.
- When hard link is created for a file, it directly points to the Inode of the original file in the disk space, which means no new Inode is created. Directories are not created using hard links and they can not cross filesystem boundaries. When the source file is removed or moved, then hard links are not affected.

2) Soft Links (Symbolic Links):
- Soft links are very common. It represents a virtual or abstract location of the file. It is just like the shortcuts created in Windows. A soft link doesn't contain any information or content of the linked file, instead it has a pointer to the location of the linked file. In other words, a new file is created with new Inode, having a pointer to the Inode location of the original file.
- It is used to create link between directories and can cross filesystem boundaries. When the source file is removed or moved, then soft links are not updated.
- We'll study in deep about both the links how to create it and remove it.

Linux File Link Topics:
		Inodes
		Directories
		Hard links
		Soft links
		To remove a link
		
a) Linux Inodes:
- An Inode number is a uniquely existing number for all the files in Linux and all Unix type systems.
- When a file is created on a system, a file name and Inode number is assigned to it.
- Generally, to access a file, a user uses the file name but internally file name is first mapped with respective Inode number stored in a table.
Note: Inode doesn't contain the file name. Reason for this is to maintain hard-links for the files. When all the other information is separated from the file name then only we can have various file names pointing to the same Inode.

Inode Contents:
An Inode is a data structure containing metadata about the files.
Following contents are stored in the Inode from a file:
		User ID of file
		Group ID of file
		Device ID
		File size
		Date of creation
		Permission
		Owner of the file
		File protection flag
		Link counter to determine number of hard links
Example: ls -ld new1  

Inode Table: 
- The Inode table contains all the Inodes and is created when file system is created. The df -i command can be used to check how many inodes are free and left unused in the filesystem.
- the command "df -i" shows the usage of several file systems.

Inode Number: 
Each Inode has a unique number and Inode number can be seen with the help of ls -li command.
Note: The Inode doesn't contain file content, instead it has a pointer to that data.
 
b) What is a Directory:
A directory is a table which contains all its files Inode number and connect it to the file system.
Example: ls -ali new1   
command "ls -ali new1" displays all the files of directory new1.

Dot (.) and DotDot (..) :
By looking at the earlier snapshot, you can notice there are two files with file name dot (.) and dotdot (.)
The dot (.) is a mapping to itself and the dotdot (.) is a mapping to the parent directory.

c) Hard Links:
Creating Hard Links:
- Hard links for any file can be created with command ln. One extra hard link file will be created in the respective directory.
- The original file and hard linked file both contain the same Inode number and hence, they have the same permissions and same owners. Content will also be the same for both the files. In short, both the files are equal now, but if original file will be removed then hard link file will not be affected.

Finding Hard Links:
- A hard link can be find with find command by specifying the Inode number. Inode number is always unique to its partition.
Example: find / -inum 662786 2> /dev/null 

d) Symbolic Links or Soft Links:
Symbolic links are also called soft links. Command ln -s is used to create soft link. It doesn't link to Inodes but create a name to mapping. It create its own Inode number.
Example: ln -s xyz symlink_to_xyz 

e) Removing Links:
With rm command links can be removed.  
directory link contains both hard link and soft link. With the command rm we have removed both the links.
##################################################################################################################################################################################################################################################################
Topic12: Vi Editor with Commands
Q) What is vi? 
A) The vi editor is elaborated as visual editor. It is installed in every Unix system. In other words, it is available in all Linux distros. It is user-friendly and works same on different distros and platforms. It is a very powerful application. An improved version of vi editor is vim.

The vi editor has two modes:
Command Mode: In command mode, actions are taken on the file. The vi editor starts in command mode. Here, the typed words will act as commands in vi editor. To pass a command, you need to be in command mode.
Insert Mode: In insert mode, entered text will be inserted into the file. The Esc key will take you to the command mode from insert mode.
- By default, the vi editor starts in command mode. To enter text, you have to be in insert mode, just type 'i' and you'll be in insert mode. Although, after typing i nothing will appear on the screen but you'll be in insert mode. Now you can type anything.
- To exit from insert mode press Esc key, you'll be directed to command mode.
- If you are not sure which mode you are in, press Esc key twice and you'll be in command mode.

Using vi:
- The vi editor tool is an interactive tool as it displays changes made in the file on the screen while you edit the file.
- In vi editor you can insert, edit or remove a word as cursor moves throughout the file.
- Commands are specified for each function like to delete it's x or dd.
- The vi editor is case-sensitive. For example, p allows you to paste after the current line while P allows you to paste before the current line.
			vi syntax: vi <fileName>  
- In the terminal when you'll type vi command with a file name, the terminal will get clear and content of the file will be displayed. If there is no such file, then a new file will be created and once completed file will be saved with the mentioned file name.

Linux vi example:
Let's understand vi through an example:
- To start vi open your terminal and type vi command followed by file name. If your file is in some other directory, you can specify the file path. And if in case, your file doesn't exist, it will create a new file with the specified name at the given location.
Example: vi /home/sssit/Downloads/file.txt  

Command mode:
- This is what you'll see when you'll press enter after the above command. If you'll start typing, nothing will appear as you are in command mode. By default vi opens in command mode.
- Look at the above snapshot, it is blank as it is a new file. To start typing, you have to move to the insert mode. At the end of the terminal window, directory name and file name are displayed.

Insert mode:
- To move to the insert mode press i. Although, there are other commands also to move to insert mode which we'll study in next page.
 after pressing i we have entered into insert mode. Now we can write anything. To move to the next line press enter.
Once you have done with your typing, press esc key to return to the command mode.

To save and quit:
- You can save and quit vi editor from command mode. Before writing save or quit command you have to press colon (:). Colon allows you to give instructions to vi.

exit vi table:
-----------------------------------------------------------------
Commands	|		Action
------------------------------------------------------------------
:wq			|	Save and quit
:w			|	Save
:q			|	Quit
:w fname	|	Save as fname
ZZ			|	Save and quit
:q!			|	Quit discarding changes made
:w!			|	Save (and write to non-writable file)
------------------------------------------------------------------
To exit from vi, first ensure that you are in command mode. Now, type :wq and press enter. It will save and quit vi.
Type :wq to save and exit the file.
command :wq will save and quit the vi editor. When you'll type it in command mode, it will automatically come at bottom left corner.
If you want to quit without saving the file, use :q. This command will only work when you have not made any changes in the file.
this file is modified and hence on typing :q it displays this message at bottom left corner.
The above file can be saved with the command :!q. It discards the changes made in the file and save it.
we have typed :!q, it will save our file by discarding the changes made.

Vi Commands:
- Linux vi editor is different from other editors. You have to use different keys to use different functions. Although, it's quite easy and interesting to use vi editor.
- The vi editor commands are case sensitive.
- Have a look at the vi commands in the following table.

To switch from command to insert mode:
---------------------------------------------------------------------------------------------------
Command	|			Action
---------------------------------------------------------------------------------------------------
i		|	Start typing before the current character
I		|	Start typing at the start of current line
a		|	Start typing after the current character
A		|	Start typing at the end of current line
o		|	Start typing on a new line after the current line
O		|	Start typing on a new line before the current line
---------------------------------------------------------------------------------------------------

To move around a file:
---------------------------------------------------------------------------------------------------
Commands	|		Action
---------------------------------------------------------------------------------------------------
j			|	To move down
k			|	To move up
h			|	To move left
l			|	To move right
---------------------------------------------------------------------------------------------------

To jump lines:
---------------------------------------------------------------------------------------------------
Commands	|			Action
---------------------------------------------------------------------------------------------------
G			|	Will direct you at the last line of the file
``			|	Will direct you to your last position in the file
---------------------------------------------------------------------------------------------------

To delete:
---------------------------------------------------------------------------------------------------
Commands	|				Action
---------------------------------------------------------------------------------------------------
x			|	Delete the current character
X			|	Delete the character before the cursor
r			|	Replace the current character
xp			|	Switch two characters
dd			|	Delete the current line
D			|	Delete the current line from current character to the end of the line
dG			|	delete from the current line to the end of the file
---------------------------------------------------------------------------------------------------

To repeat and undo:
---------------------------------------------------------------------------------------------------
Commands	|		Action
---------------------------------------------------------------------------------------------------
u			|	Undo the last command
.			|	Repeat the last command
---------------------------------------------------------------------------------------------------

Command to cut, copy and paste:
---------------------------------------------------------------------------------------------------
Commands	|			Action
---------------------------------------------------------------------------------------------------
dd			|	Delete a line
yy			|	(yank yank) copy a line
p			|	Paste after the current line
P			|	Paste before the current line
---------------------------------------------------------------------------------------------------

Command to cut, copy and paste in blocks:
---------------------------------------------------------------------------------------------------
Commands	|			Action
---------------------------------------------------------------------------------------------------
<n>dd		|	Delete the specified n number of lines
<n>yy		|	Copy the specified n number of lines
---------------------------------------------------------------------------------------------------

Start and end of line:
---------------------------------------------------------------------------------------------------
Commands	|			Action
---------------------------------------------------------------------------------------------------
			|	Bring at the start of the current line
^			|	Bring at the start of the current line
$			|	Bring at the end of the current line
d			|	Delete till start of a line
d$			|	Delete till end of a line
---------------------------------------------------------------------------------------------------

Joining lines:
---------------------------------------------------------------------------------------------------
Commands	|			Action
---------------------------------------------------------------------------------------------------
J			|	Join two lines
yyp			|	Repeat the current line
ddp			|	Swap two lines
---------------------------------------------------------------------------------------------------

Move forward or backward:
---------------------------------------------------------------------------------------------------
Commands		|			Action
---------------------------------------------------------------------------------------------------
w				|	Move one word forward
b				|	Move one word backward
<n>w			|	Move specified number of words forward
dw				|	Delete one word
yw				|	Copy one word
<n>dw			|	Delete specified number of words
---------------------------------------------------------------------------------------------------

Search a string:
---------------------------------------------------------------------------------------------------
Commands		|				Action
---------------------------------------------------------------------------------------------------
/string			|	Forward search for given string
?string			|	Backward search for given string
/^string		|	Forward search string at beginning of a line
/string$		|	Forward search string at end of a line
n				|	Go to next occurrence of searched string
/\<he\>			|	Search for the word he (and not for there, here, etc.)
/pl[abc]ce		|	Search for place, plbce, and plcce
---------------------------------------------------------------------------------------------------

Replace all:
Syntax:
:<startLine,endLine> s/<oldString>/<newString>/g  
Example:
---------------------------------------------------------------------------------------------------
Commands					|					Action
---------------------------------------------------------------------------------------------------
:1,$ s/readable/changed/	|	Replace forward with backward from first line to the last line
:3,6 s/letters/neww/g		|	Replace forward with backward from third line to the ninth line
---------------------------------------------------------------------------------------------------

Text buffers:
---------------------------------------------------------------------------------------------------
Commands		|		Action
---------------------------------------------------------------------------------------------------
"add			|	Delete current line and put text in buffer a
"ap				|	Paste the line from buffer a
---------------------------------------------------------------------------------------------------

Abbreviation
Syntax:
:ab <abbreviation> <abbreviatedWord>  
Example:
---------------------------------------------------------------------------------------------------
Commands								|					Action
---------------------------------------------------------------------------------------------------
:ab au abbrevition and unabbreviation	|	Abbreviate au to be 'abbrevition and unabbreviation'
:una au          						|	Un - abbreviate au
---------------------------------------------------------------------------------------------------

						Vi Editor Index: https://www.javatpoint.com/vi-editor
							Vi Editor
							1) switch
							2) move
							3) jump
							4) delete
							5) undo and repeat
							6) cut, copy, paste
							7) cut, copy, paste blocks
							8) Start and end
							9) Joining
							10) word
							11) Search
							12) Replace all
							13) Text Buffers
							14) Abbreviation
							
1) vi switch from command mode: https://www.javatpoint.com/linux-vi-switch ----> for better understanding of examples
- To start typing in vi editor, you have to be in insert mode. There are different commands in vi editor through which you can start typing at different locations in insert mode. They are defined below.
			i
The i command allows us to write before the current character.
Example:
Look at the above snapshot, our cursor is at e. We forgot to write word command before word example. Hence, here we can use i command.
Look at the above snapshot, after pressing i, we wrote word command.

I :
The command I allows us to write at the start of the current line.
Example:
Look at the above snapshot, we want to write word Hello at the starting of the line.
Look at the above snapshot, after pressing I, we have typed Hello at the starting of the line.

A:
The A command allows us to start typing at the end of the current line.
Example:
Look at the above snapshot, we want to move at the end of the current line.
Look at the above snapshot, after pressing A, we have written one more line.

o:
The o command allows us to start typing a new line after the current line.
Example:
Look at the above snapshot, we are at the middle of the line and want to start a new line.
Look at the above snapshot, after pressing o, we arrived at next line and typed there.

O:
The O command allows us to start typing on a new line before the current line.
Example:
Look at the above snapshot, we are at the middle of the line and want to write before the current line.
Look at the above snapshot, after pressing O, we have written in a new line before the current line.

2) vi move around a file: https://www.javatpoint.com/linux-vi-move ----> for better understanding of examples
- In command mode, we can move to different parts of a file with h,j,k,l commands. These (h,j,k,l) keys are used because at the time of vi invention, arrow keys were not invented. Although, we can use arrow keys also. Arrow keys and h,j,k,l keys work same.

j:
The j command works same as the downward arrow. You can move to the below lines.
Example:
Look at the above snapshot, letter e is repeated twice. To correct that we need to go to that line.
Look at the above snapshot, after pressing either j key or downward key, we moved to that line and corrected it.

k:
The k command works same as the upward arrow. You can move to the above lines.
Example:
Look at the above snapshot, our cursor is at letter e and we want to move up at the blank line to write something.
Look at the above snapshot, after pressing either k key or upward key, we moved to the upper line and have written over there.

h:
The h command works same as the leftward arrow. You can move in leftwards direction.
Example:
Look at the above snapshot, our cursor is at the end and we want to move to the starting of the second line.
Look at the above snapshot, after pressing either h key or leftward key, we're at starting of the second line.

l:
The l command works same as the rightward arrow. You can move in rightwards direction.
Example:
Look at the above snapshot, we are at starting and we want to move to the end of the last line
Look at the above snapshot, after pressing either l key or rightward arrow, we're at the end of the last line.

3) vi jump: https://www.javatpoint.com/linux-vi-jump ----> for better understanding of examples
- When you move around a file you need to switch from one line to another line. Although you can do this with j,k keys or arrow keys. But when your file is too large, you can use G command. If you'll type a number before G then you'll be directed to the typed line number. And if you'll type only G then you'll be directed to the last line of the file.
- One important command in vi editor is (``). it will help you to come back at the earlier position in the file. For example, if you are on line 4, by using 10G command you reach at line 10. But you forgot to edit something in line 4 and want to go back to line 4, here you can use `` which will redirect you to line 4.

nG:
Here n denotes a number. You can type a number before G to jump to a particular line.
Example:
Look at the above snapshot, our cursor is at line 1 and we want to go to the line 7.
Look at the above snapshot, in command mode after typing 7G (you'll not be able to see the typed command 7G on the screen), we're at 7th line.

G:
If you'll not type any number before G, then you'll be directed to last line of the file.
Look at the above snapshot, our cursor is at line 1.
Look at the above snapshot, after pressing G, we're at the last line of the file.

``
This command allows us to move to the previous position in the file.
Example:
Look at the above snapshot, we are at line number 9.
Look at the above snapshot, we are at line 5 but forgot to write something on line 9.
Look at the above snapshot, after typing `` we moved back to line 9.

4)vi delete; https://www.javatpoint.com/linux-vi-delete ----> for better understanding of examples
- You can delete or remove characters in different ways. r key is used to replace one single character. The r key will bring you in insert mode for just one key press and then you'll be directed to command mode.

x:
The command x is used to delete current character.
Example:
Look at the above snapshot, our cursor is at letter d and we want to delete it.
Look at the above snapshot, after pressing x, letter d is removed.

x:
The command X is used to delete character before the cursor.
Example:
Look at the above snapshot, our current character is letter d, and we want to delete letter before current character that is c.
Look at the above snapshot, after pressing X, letter before current character (c) is deleted.

r:
The r key will bring you in insert mode for just one key press and then you'll be again directed to command mode.
Example:
Look at the above snapshot, we want to replace 7 from 6 Linux Vi Delete6
Look at the above snapshot, after pressing r, type 6 to replace number 7.

xp:
The command xp allows us to switch two characters. The character at the right of the cursor will come at the place of the cursor, and character at the cursor will switch to the right of the cursor.
Example:
Look at the above snapshot, our cursor is at character e. Word teh is wrongly spelt. To correct it r can be used.
Look at the above snapshot, both the characters that is character at the cursor (e) and character at the right of the cursor (h) are switched from their positions. Hence now word teh becomes the.

dd:
The command dd deletes current line completely.
Example:
Look at the above snapshot, our cursor is at line third. We want to delete this whole line.
Look at the above snapshot, after pressing dd command, third line is deleted.

D:
The command D is used to delete from current character to the end of the line.
Example:
Look at the above snapshot, our cursor is at third line at letter a. We want to delete from the current character till the end of the line.
Look at the above snapshot, after pressing D, all the characters are deleted from letter a to the end line.

dG:
The command dG is used to delete from current line to the end line of the file.
Example:
Look at the above snapshot, currently our cursor is at second line.
Look at the above snapshot, all the lines are deleted from second line to the end line.

5) vi undo and repeat: https://www.javatpoint.com/linux-vi-undo-and-repeat  ----> for better understanding of examples
- In command mode, to undo the last command u is used and if you want to repeat the last command use dot (.).

u:
This command allows us to undo or cancel our last command.
Example:
Look at the above snapshot, this is our script.
Look at the above snapshot, with the help of dG command we have deleted last lines.
Look at the above snapshot, after pressing u, last command dG disables and all the content came back.

(.)
The . command allows us to repeat last used command.
Example:
Look at the above snapshot, we have used D command to delete some part of line second.

6) vi cut, copy and paste (Line):  https://www.javatpoint.com/linux-vi-cut-copy-paste ----> for better understanding of examples
- In command mode, you can cut, copy and paste a line with the following commands.

cut
dd
The command dd deletes current line completely.
Example:
Look at the above snapshot, our cursor is at line third. We want to delete this whole line.
Look at the above snapshot, after pressing dd command, third line is deleted.

copy
yy
The command yy (yank yank) is used to copy a line. Move the cursor to the line you want to copy and then press yy.

paste
p
The p command paste a copied or cut content after the current line.

Example:
Look at the above snapshot, this is our original script.
Look at the above snapshot, first we have copied the second line using yy, then press p. Copied line will paste after the current line.

P:
The P command paste a copied or cut content before the current line.
Example:
Look at the above snapshot, this is our original script.
Look at the above snapshot, after copying the content using yy, we moved the cursor to first line and then pressed P. Line is copied before the current line.

7) vi cut, copy and paste a line in blocks: https://www.javatpoint.com/linux-vi-cut-copy-paste-blocks ----> for better understanding of examples
- TIn command mode, if you want to delete, cut or copy n number of lines, just type the number before typing the command. For example, 4dd will delete four number of lines from the current line to the next three lines in downward direction.
- In case of yy command, command will be noted by vi. For example, if we have given command 4yy then at the bottom left corner, vi will show a message as "4 lines yanked".

Cut
ndd
Here n denotes a number. It will delete n number of lines after the current line.
Example:
2dd
Look at the above snapshot, this is our script and we want to delete first two lines.
Look at the above snapshot, after typing 2dd, two lines after the current lines are deleted.

Copy
nyy
The command nyy is used to copy n number of lines after the current line.
Example:
2yy
Look at the above snapshot, we want to copy two lines after the first line.
Look at the above snapshot, after pressing 2yy, last two lines are copied and with P key we have pasted them before the first line.

8) vi Start and End of a line: https://www.javatpoint.com/linux-vi-start-and-end ----> for better understanding of examples
- In command mode, 0 and caret ^ sign will bring you at the start of the current line while $ sign will bring you at the end of the current line.
- These signs can be added to another command to perform certain functions. For example, d0 will delete characters between current character and start of the line. And d$ will delete characters between current character and end of the line.

0
The 0 sign bring you to the start of the current line.
Example:
Look at the above snapshot, currently our cursor is at the middle of the second line.
Look at the above snapshot, after pressing key 0, we're at the starting of second line.

^
The ^ sign also bring you at the start of the current line.

$
The $ sign will bring you to the end of the current line.
Example:
Look at the above snapshot, currently our cursor is at the middle of the second line.
Look at the above snapshot, after pressing $ key, we are at the end of the current line.

d0
Combining sign 0 with d command enables us to delete start of a line from current character.
Example:
Look at the above snapshot, position of the cursor is somewhere in the middle of the line.
Look at the above snapshot, letters from starting to the current character are deleted.

d$
Combining sign $ with d command enables us to delete from current character to the end of the line.
Example:
Look at the above snapshot, position of the cursor is somewhere in the middle of the line.
Look at the above snapshot, letters from current character to the end of the line are deleted.

9) vi Join two lines and more: https://www.javatpoint.com/linux-vi-joining ----> for better understanding of examples
- In command mode, two lines can be joined, switched and repeated.

J
The J command can be used to join two lines.
Example:
Look at the above snapshot, we need to join first two lines of the above script.
Look at the above snapshot, after pressing J, both the lines are joined.

yyp
The yyp command repeat the current line.
Example:
Look at the above snapshot, our current line is the second line.
Look at the above snapshot, after pressing yyp command, current line is repeated.

ddp
The command ddp swaps two lines (current line and line below the current line).
Example:
Look at the above snapshot, last two lines are swapped from their positions.

10) vi Words: https://www.javatpoint.com/linux-vi-word ----> for better understanding of examples
- In command mode, you can move one word forward or backward with w and b command respectively.

w
The w command allows us to move one word forward. To move more than one word forward, you can type number before w command.
Example:
9w
Look at the above snapshot, from the current word we want to move 9 words ahead.
Look at the above snapshot, we have moved 9 words forward.
Note: Word we'll is counted as three words (we, ' , and ll)

b
The b command allows us to move one word backward. To move more than one word backward, you can type number before b command.
Example:
9b
Look at the above snapshot, from the current word we want to move 9 words backwards.
Look at the above snapshot, we have moved 9 words backward.

dw
The dw command is used to delete one word. But remember, to delete one complete word cursor should be placed at the starting letter of the word.
Example 1:
Look at the above snapshot, we want to delete word example. Our cursor is placed at the starting letter e.
Look at the above snapshot, after pressing dw command, word example is deleted.
Example 2:
Look at the above snapshot, here also we want to delete word example. But this time our cursor is placed somewhere at the middle of the word.
Look at the above snapshot, after pressing dw command, word example is not completely deleted. Only the letters starting from the cursor to the end of the word (including the space) are deleted.
Example 3:
5dw
Look at the above snapshot, here we want to delete five letters after the current word.
Look at the above snapshot, after typing 5dw, five words after the cursor are deleted.

yw
The command yw is used to copy one word. Here also cursor has to be placed at the starting to copy a complete word.
Example:
Look at the above snapshot, we want to copy word example.
Look at the above snapshot, after pressing yw key, move the cursor at place where you want to copy the word. Here, we have copied it at the last with p command.

11) vi Searching: https://www.javatpoint.com/linux-vi-searhing ----> for better understanding of examples
- In command mode, with the help of '/' , string can be searched in forward direction and with the help of ? , string can be searched in backward direction. For example, /abc will do a forward search for string abc whereas ?abc will do a backward search for string abc.

/string
Here string has to be replaced by the searching word.
The /string allows us to do forward search for a string. If the same string is placed before and after the cursor, it will only indicate the string after the cursor. When you'll start typing /string in command mode, at lower left corner, typed word will be seen.
Example:
/readable
Look at the above snapshot, this is our normal script. We have to search word readable from this script.
Look at the above snapshot, after typing /readable and pressing enter, mentioned word on its first occurence will be automatically highlighted. Please note here, first occurence is in forward search. The string readable is also present before the cursor, but it searches forward.

?string
The ?string allows us to do backward search for a string. If the same string is placed before and after the cursor, it will only indicate the string before the cursor. When you'll start typing ?string in command mode, at lower left corner, typed word will be seen.
Example:
/readable
Look at the above snapshot, this is our normal script. We have to search word readable from this script.
Look at the above snapshot, after typing ?readable and pressing enter, mentioned word on its first occurence will be automatically highlighted. Please note here, first occurence is in backward search. The string readable is also present after the cursor, but it searches backward.

/^string
This command searches a string in forward direction but at the beginning of a line. If no such word is present at the beginning of the line, it will show a no match message.
Example:
/^readable
Look at the above snapshot, after typing /^readable, cursor moved to the string which is at the starting of the line.

/string$
This command searches string in forward direction but at the end of a line. If no such word is present at the end of the line, it will show a no match message.
Example:
/readable$
Look at the above snapshot, after typing /readable$, cursor moved to the string which is at the end of the line.

n
The n command indicates the next occurence of the searched string.
Look at the above snapshot, cursor is at first occurence of string.
Look at the above snapshot, after pressing n, cursor is at next occurence of the string.

/\
This command only searches for specifically the word enclosed in <>.
Example 1:
/\
Look at the above snapshot, after typing /\<he\> command, we got the word he.
Example 2:
/he
Look at the above snapshot, after searching for he with command /he, cursor has highlighted he from the word.

/pl[abc]ce
This command is helpful when you are in doubt with the spelling of a word. Here you can write all the possibilities related to your search.
Example:
/cont[ae]nt
Look at the above snapshot, after typing command /cont[ae]nt, word content is highlighted.

12) vi Replace All: https://www.javatpoint.com/linux-vi-replace-all ----> for better understanding of examples
- In command mode, you can replace a string with another string. For this, first you have to type : to move to ex mode. Then select a range of lines from where strings have to be replaced.
- If you want to replace a string starting from first line to the last line 1,$ can be uesd. To replace from a particular line mention the starting and last line number. For example, 2,5 will replace from second line to the fifth line.

Syntax:
:<startLine,endLine> s/<oldString>\/<newString>/g
Note: Here g stands for globally. If the string is repeating more than once in a single line, then g is to be used to replace it globally from all the places in the mentioned line range.
Example 1:
:1,$ s/readable/changed/
Look at the above snapshot, we have written the command :1,$ s/readable/changed/
After pressing enter key, string readable is replaced with string changed.
Example 1:
:3,6 s/letters/neww/g
Look at the above snapshot, we have written the command :1,$ s/letters/neww/g
After pressing enter key, string letters is replaced with string neww.

13) vi Text buffers: https://www.javatpoint.com/linux-vi-text-buffers ----> for better understanding of examples
- A buffer is a computer's memory, that acts as a temporary holding place for data that is being sent to or received from an external device like keyboard, hard disk, printer etc. There are 36 buffers in vi to store text. Command starts with (") character.
- The vi editor doesn't allow direct modification of the file, instead it makes a copy of the edited file which is saved in buffer.
Example: "add
Here a is one of the buffer out of 36 buffers, dd is the command to delete a line. This command will delete the current line and will save it in buffer a.
Look at the above snapshot, currently we're at line number four.
Look at the above snapshot, after pressing command "add, current line (fourth line) is deleted and is saved in buffer a.
"ap
Here also a is one of the buffer out of 36 buffers, p is the command to paste. This command will paste a line from buffer a after the current cursor position.
Look at the above snapshot, we want to paste a line from buffer a after the current cursor position.
Look at the above snapshot, after passing "ap command, line which was saved in buffer a (in last example) is pasted back after the current position that is at the last.

14) vi Abbreviations: https://www.javatpoint.com/linux-vi-abbreviations ----> for better understanding of examples
- In vi, abbreviations can also be used with command :ab. To undo abbreviation, use command :una.
- TIn vi, you can define abbreviations that will automatically expand when you'll type abbreviation in insert mode.
Syntax:
:ab <abbreviation> <abbreviatedWord>
:una <abbreviatedWord>
Example for ab:
:ab au abbreviation and unabbreviation
Look at the above snapshot, we have passed the command to abbreviate in command mode.
Look at the above snapshot, in insert mode, after typing au, it is automatically expanded in its full form.
Example for una:
:una abbreviation and unabbreviation
Look at the above snapshot, with command una we undo abbreviation au. After typing au, in insert mode, it is not abbreviated.

													-***************** The END *****************-